/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ytsr";
exports.ids = ["vendor-chunks/ytsr"];
exports.modules = {

/***/ "(rsc)/./node_modules/ytsr/lib/main.js":
/*!***************************************!*\
  !*** ./node_modules/ytsr/lib/main.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PARSE_ITEM = __webpack_require__(/*! ./parseItem.js */ \"(rsc)/./node_modules/ytsr/lib/parseItem.js\");\nconst MINIGET = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\nconst UTIL = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/ytsr/lib/utils.js\");\nconst QS = __webpack_require__(/*! querystring */ \"querystring\");\n\nconst BASE_SEARCH_URL = 'https://www.youtube.com/results?';\nconst BASE_API_URL = 'https://www.youtube.com/youtubei/v1/search?key=';\n\nconst main = module.exports = async(searchString, options, rt = 3) => {\n  if (rt === 0) throw new Error('Unable to find JSON!');\n  // Set default values\n  const opts = UTIL.checkArgs(searchString, options);\n\n  const ref = BASE_SEARCH_URL + QS.encode(opts.query);\n  const body = await MINIGET(ref, opts.requestOptions).text();\n  const parsed = UTIL.parseBody(body, opts);\n  // Retry if unable to find json => most likely old response\n  if (!parsed.json) return main(searchString, options, rt - 1);\n\n  // Pass Errors from the API\n  if (parsed.json.alerts && !parsed.json.contents) {\n    let error = parsed.json.alerts.find(a => a.alertRenderer && a.alertRenderer.type === 'ERROR');\n    if (error) throw new Error(`API-Error: ${UTIL.parseText(error.alertRenderer.text, '* no message *')}`);\n  }\n\n  const resp = {\n    // Query that was searched\n    originalQuery: opts.search,\n    // Query that youtube shows results for\n    correctedQuery: opts.search,\n    results: Number(parsed.json.estimatedResults) || 0,\n    activeFilters: [],\n    refinements: [],\n    items: [],\n    continuation: null,\n  };\n  // Add refinements\n  if (Array.isArray(parsed.json.refinements)) {\n    parsed.json.refinements.map(r => ({\n      q: r,\n      url: new URL(r, BASE_SEARCH_URL).toString(),\n      bestThumbnail: null,\n      thumbnails: null,\n    }));\n  }\n\n  // General wrapper\n  const { rawItems, continuation } = UTIL.parseWrapper(\n    parsed.json.contents.twoColumnSearchResultsRenderer.primaryContents,\n  );\n\n  // Parse items\n  resp.items = rawItems.map(a => PARSE_ITEM(a, resp)).filter(a => a).filter((_, index) => index < opts.limit);\n\n  // Adjust tracker\n  opts.limit -= resp.items.length;\n  opts.pages -= 1;\n\n  // Get information about set filters\n  const filters = UTIL.parseFilters(parsed.json);\n  resp.activeFilters = Array.from(filters).map(a => a[1].active).filter(a => a);\n\n  // Parse the nextpageToken\n  let token = null;\n  if (continuation) token = continuation.continuationItemRenderer.continuationEndpoint.continuationCommand.token;\n  // Only provide continuation if we're pulling all items or using paging\n  if (token && opts.limit === Infinity) resp.continuation = [parsed.apiKey, token, parsed.context, opts];\n\n  // We're already on last page or hit the limit\n  if (!token || opts.limit < 1 || opts.pages < 1) return resp;\n\n  // Recursively fetch more items\n  const nestedResp = await parsePage2(parsed.apiKey, token, parsed.context, opts);\n\n  // Merge the responses\n  resp.items.push(...nestedResp.items);\n  resp.continuation = nestedResp.continuation;\n  return resp;\n};\nmain.version = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/ytsr/package.json\").version);\n\nconst parsePage2 = async(apiKey, token, context, opts) => {\n  const json = await UTIL.doPost(BASE_API_URL + apiKey, { context, continuation: token }, opts.requestOptions);\n\n  if (!Array.isArray(json.onResponseReceivedCommands)) {\n    // No more content\n    return { continuation: null, items: [] };\n  }\n\n  const { rawItems, continuation } = UTIL.parsePage2Wrapper(\n    json.onResponseReceivedCommands[0].appendContinuationItemsAction.continuationItems,\n  );\n\n  // Parse items\n  const parsedItems = rawItems.map(a => PARSE_ITEM(a)).filter(a => a).filter((_, index) => index < opts.limit);\n\n  // Adjust tracker\n  opts.limit -= parsedItems.length;\n  opts.pages -= 1;\n\n  // Parse the nextpageToken\n  let nextToken = null;\n  if (continuation) nextToken = continuation.continuationItemRenderer.continuationEndpoint.continuationCommand.token;\n\n  // We're already on last page or hit the limit\n  if (!nextToken || opts.limit < 1 || opts.pages < 1) {\n    return {\n      continuation: nextToken && opts.limit === Infinity ? [apiKey, nextToken, context, opts] : null,\n      items: parsedItems,\n    };\n  }\n\n  // Recursively fetch more items\n  const nestedResp = await parsePage2(apiKey, nextToken, context, opts);\n  nestedResp.items.unshift(...parsedItems);\n  return nestedResp;\n};\n// eslint-disable-next-line require-await\nmain.continueReq = async args => {\n  // Check params\n  if (!Array.isArray(args) || args.length !== 4) throw new Error('invalid continuation array');\n  if (!args[0] || typeof args[0] !== 'string') throw new Error('invalid apiKey');\n  if (!args[1] || typeof args[1] !== 'string') throw new Error('invalid token');\n  if (!args[2] || typeof args[2] !== 'object') throw new Error('invalid context');\n  if (!args[3] || typeof args[3] !== 'object') throw new Error('invalid opts');\n  if (args[3].limit !== null && !isNaN(args[3].limit) && isFinite(args[3].limit)) {\n    throw new Error('continueReq only allowed for paged requests');\n  }\n  // Enforce pagination information\n  args[3].pages = 1;\n  args[3].limit = Infinity;\n  return parsePage2(...args);\n};\n\nmain.getFilters = async(searchString, options) => {\n  const opts = UTIL.checkArgs(searchString, options);\n\n  const ref = BASE_SEARCH_URL + QS.encode(opts.query);\n  const body = await MINIGET(ref, opts.requestOptions).text();\n  const parsed = UTIL.parseBody(body);\n  // Retry if old response\n  if (!parsed.json) return main.getFilters(searchString, options);\n  return UTIL.parseFilters(parsed.json);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRzci9saWIvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDBEQUFZO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyREFBMkQ7QUFDeEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEZBQWtDOztBQUVqRDtBQUNBLDBEQUEwRCw4QkFBOEI7O0FBRXhGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYW50dWJlLy4vbm9kZV9tb2R1bGVzL3l0c3IvbGliL21haW4uanM/NDUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQQVJTRV9JVEVNID0gcmVxdWlyZSgnLi9wYXJzZUl0ZW0uanMnKTtcbmNvbnN0IE1JTklHRVQgPSByZXF1aXJlKCdtaW5pZ2V0Jyk7XG5jb25zdCBVVElMID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xuY29uc3QgUVMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5jb25zdCBCQVNFX1NFQVJDSF9VUkwgPSAnaHR0cHM6Ly93d3cueW91dHViZS5jb20vcmVzdWx0cz8nO1xuY29uc3QgQkFTRV9BUElfVVJMID0gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3lvdXR1YmVpL3YxL3NlYXJjaD9rZXk9JztcblxuY29uc3QgbWFpbiA9IG1vZHVsZS5leHBvcnRzID0gYXN5bmMoc2VhcmNoU3RyaW5nLCBvcHRpb25zLCBydCA9IDMpID0+IHtcbiAgaWYgKHJ0ID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIEpTT04hJyk7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlc1xuICBjb25zdCBvcHRzID0gVVRJTC5jaGVja0FyZ3Moc2VhcmNoU3RyaW5nLCBvcHRpb25zKTtcblxuICBjb25zdCByZWYgPSBCQVNFX1NFQVJDSF9VUkwgKyBRUy5lbmNvZGUob3B0cy5xdWVyeSk7XG4gIGNvbnN0IGJvZHkgPSBhd2FpdCBNSU5JR0VUKHJlZiwgb3B0cy5yZXF1ZXN0T3B0aW9ucykudGV4dCgpO1xuICBjb25zdCBwYXJzZWQgPSBVVElMLnBhcnNlQm9keShib2R5LCBvcHRzKTtcbiAgLy8gUmV0cnkgaWYgdW5hYmxlIHRvIGZpbmQganNvbiA9PiBtb3N0IGxpa2VseSBvbGQgcmVzcG9uc2VcbiAgaWYgKCFwYXJzZWQuanNvbikgcmV0dXJuIG1haW4oc2VhcmNoU3RyaW5nLCBvcHRpb25zLCBydCAtIDEpO1xuXG4gIC8vIFBhc3MgRXJyb3JzIGZyb20gdGhlIEFQSVxuICBpZiAocGFyc2VkLmpzb24uYWxlcnRzICYmICFwYXJzZWQuanNvbi5jb250ZW50cykge1xuICAgIGxldCBlcnJvciA9IHBhcnNlZC5qc29uLmFsZXJ0cy5maW5kKGEgPT4gYS5hbGVydFJlbmRlcmVyICYmIGEuYWxlcnRSZW5kZXJlci50eXBlID09PSAnRVJST1InKTtcbiAgICBpZiAoZXJyb3IpIHRocm93IG5ldyBFcnJvcihgQVBJLUVycm9yOiAke1VUSUwucGFyc2VUZXh0KGVycm9yLmFsZXJ0UmVuZGVyZXIudGV4dCwgJyogbm8gbWVzc2FnZSAqJyl9YCk7XG4gIH1cblxuICBjb25zdCByZXNwID0ge1xuICAgIC8vIFF1ZXJ5IHRoYXQgd2FzIHNlYXJjaGVkXG4gICAgb3JpZ2luYWxRdWVyeTogb3B0cy5zZWFyY2gsXG4gICAgLy8gUXVlcnkgdGhhdCB5b3V0dWJlIHNob3dzIHJlc3VsdHMgZm9yXG4gICAgY29ycmVjdGVkUXVlcnk6IG9wdHMuc2VhcmNoLFxuICAgIHJlc3VsdHM6IE51bWJlcihwYXJzZWQuanNvbi5lc3RpbWF0ZWRSZXN1bHRzKSB8fCAwLFxuICAgIGFjdGl2ZUZpbHRlcnM6IFtdLFxuICAgIHJlZmluZW1lbnRzOiBbXSxcbiAgICBpdGVtczogW10sXG4gICAgY29udGludWF0aW9uOiBudWxsLFxuICB9O1xuICAvLyBBZGQgcmVmaW5lbWVudHNcbiAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkLmpzb24ucmVmaW5lbWVudHMpKSB7XG4gICAgcGFyc2VkLmpzb24ucmVmaW5lbWVudHMubWFwKHIgPT4gKHtcbiAgICAgIHE6IHIsXG4gICAgICB1cmw6IG5ldyBVUkwociwgQkFTRV9TRUFSQ0hfVVJMKS50b1N0cmluZygpLFxuICAgICAgYmVzdFRodW1ibmFpbDogbnVsbCxcbiAgICAgIHRodW1ibmFpbHM6IG51bGwsXG4gICAgfSkpO1xuICB9XG5cbiAgLy8gR2VuZXJhbCB3cmFwcGVyXG4gIGNvbnN0IHsgcmF3SXRlbXMsIGNvbnRpbnVhdGlvbiB9ID0gVVRJTC5wYXJzZVdyYXBwZXIoXG4gICAgcGFyc2VkLmpzb24uY29udGVudHMudHdvQ29sdW1uU2VhcmNoUmVzdWx0c1JlbmRlcmVyLnByaW1hcnlDb250ZW50cyxcbiAgKTtcblxuICAvLyBQYXJzZSBpdGVtc1xuICByZXNwLml0ZW1zID0gcmF3SXRlbXMubWFwKGEgPT4gUEFSU0VfSVRFTShhLCByZXNwKSkuZmlsdGVyKGEgPT4gYSkuZmlsdGVyKChfLCBpbmRleCkgPT4gaW5kZXggPCBvcHRzLmxpbWl0KTtcblxuICAvLyBBZGp1c3QgdHJhY2tlclxuICBvcHRzLmxpbWl0IC09IHJlc3AuaXRlbXMubGVuZ3RoO1xuICBvcHRzLnBhZ2VzIC09IDE7XG5cbiAgLy8gR2V0IGluZm9ybWF0aW9uIGFib3V0IHNldCBmaWx0ZXJzXG4gIGNvbnN0IGZpbHRlcnMgPSBVVElMLnBhcnNlRmlsdGVycyhwYXJzZWQuanNvbik7XG4gIHJlc3AuYWN0aXZlRmlsdGVycyA9IEFycmF5LmZyb20oZmlsdGVycykubWFwKGEgPT4gYVsxXS5hY3RpdmUpLmZpbHRlcihhID0+IGEpO1xuXG4gIC8vIFBhcnNlIHRoZSBuZXh0cGFnZVRva2VuXG4gIGxldCB0b2tlbiA9IG51bGw7XG4gIGlmIChjb250aW51YXRpb24pIHRva2VuID0gY29udGludWF0aW9uLmNvbnRpbnVhdGlvbkl0ZW1SZW5kZXJlci5jb250aW51YXRpb25FbmRwb2ludC5jb250aW51YXRpb25Db21tYW5kLnRva2VuO1xuICAvLyBPbmx5IHByb3ZpZGUgY29udGludWF0aW9uIGlmIHdlJ3JlIHB1bGxpbmcgYWxsIGl0ZW1zIG9yIHVzaW5nIHBhZ2luZ1xuICBpZiAodG9rZW4gJiYgb3B0cy5saW1pdCA9PT0gSW5maW5pdHkpIHJlc3AuY29udGludWF0aW9uID0gW3BhcnNlZC5hcGlLZXksIHRva2VuLCBwYXJzZWQuY29udGV4dCwgb3B0c107XG5cbiAgLy8gV2UncmUgYWxyZWFkeSBvbiBsYXN0IHBhZ2Ugb3IgaGl0IHRoZSBsaW1pdFxuICBpZiAoIXRva2VuIHx8IG9wdHMubGltaXQgPCAxIHx8IG9wdHMucGFnZXMgPCAxKSByZXR1cm4gcmVzcDtcblxuICAvLyBSZWN1cnNpdmVseSBmZXRjaCBtb3JlIGl0ZW1zXG4gIGNvbnN0IG5lc3RlZFJlc3AgPSBhd2FpdCBwYXJzZVBhZ2UyKHBhcnNlZC5hcGlLZXksIHRva2VuLCBwYXJzZWQuY29udGV4dCwgb3B0cyk7XG5cbiAgLy8gTWVyZ2UgdGhlIHJlc3BvbnNlc1xuICByZXNwLml0ZW1zLnB1c2goLi4ubmVzdGVkUmVzcC5pdGVtcyk7XG4gIHJlc3AuY29udGludWF0aW9uID0gbmVzdGVkUmVzcC5jb250aW51YXRpb247XG4gIHJldHVybiByZXNwO1xufTtcbm1haW4udmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbmNvbnN0IHBhcnNlUGFnZTIgPSBhc3luYyhhcGlLZXksIHRva2VuLCBjb250ZXh0LCBvcHRzKSA9PiB7XG4gIGNvbnN0IGpzb24gPSBhd2FpdCBVVElMLmRvUG9zdChCQVNFX0FQSV9VUkwgKyBhcGlLZXksIHsgY29udGV4dCwgY29udGludWF0aW9uOiB0b2tlbiB9LCBvcHRzLnJlcXVlc3RPcHRpb25zKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5vblJlc3BvbnNlUmVjZWl2ZWRDb21tYW5kcykpIHtcbiAgICAvLyBObyBtb3JlIGNvbnRlbnRcbiAgICByZXR1cm4geyBjb250aW51YXRpb246IG51bGwsIGl0ZW1zOiBbXSB9O1xuICB9XG5cbiAgY29uc3QgeyByYXdJdGVtcywgY29udGludWF0aW9uIH0gPSBVVElMLnBhcnNlUGFnZTJXcmFwcGVyKFxuICAgIGpzb24ub25SZXNwb25zZVJlY2VpdmVkQ29tbWFuZHNbMF0uYXBwZW5kQ29udGludWF0aW9uSXRlbXNBY3Rpb24uY29udGludWF0aW9uSXRlbXMsXG4gICk7XG5cbiAgLy8gUGFyc2UgaXRlbXNcbiAgY29uc3QgcGFyc2VkSXRlbXMgPSByYXdJdGVtcy5tYXAoYSA9PiBQQVJTRV9JVEVNKGEpKS5maWx0ZXIoYSA9PiBhKS5maWx0ZXIoKF8sIGluZGV4KSA9PiBpbmRleCA8IG9wdHMubGltaXQpO1xuXG4gIC8vIEFkanVzdCB0cmFja2VyXG4gIG9wdHMubGltaXQgLT0gcGFyc2VkSXRlbXMubGVuZ3RoO1xuICBvcHRzLnBhZ2VzIC09IDE7XG5cbiAgLy8gUGFyc2UgdGhlIG5leHRwYWdlVG9rZW5cbiAgbGV0IG5leHRUb2tlbiA9IG51bGw7XG4gIGlmIChjb250aW51YXRpb24pIG5leHRUb2tlbiA9IGNvbnRpbnVhdGlvbi5jb250aW51YXRpb25JdGVtUmVuZGVyZXIuY29udGludWF0aW9uRW5kcG9pbnQuY29udGludWF0aW9uQ29tbWFuZC50b2tlbjtcblxuICAvLyBXZSdyZSBhbHJlYWR5IG9uIGxhc3QgcGFnZSBvciBoaXQgdGhlIGxpbWl0XG4gIGlmICghbmV4dFRva2VuIHx8IG9wdHMubGltaXQgPCAxIHx8IG9wdHMucGFnZXMgPCAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRpbnVhdGlvbjogbmV4dFRva2VuICYmIG9wdHMubGltaXQgPT09IEluZmluaXR5ID8gW2FwaUtleSwgbmV4dFRva2VuLCBjb250ZXh0LCBvcHRzXSA6IG51bGwsXG4gICAgICBpdGVtczogcGFyc2VkSXRlbXMsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IGZldGNoIG1vcmUgaXRlbXNcbiAgY29uc3QgbmVzdGVkUmVzcCA9IGF3YWl0IHBhcnNlUGFnZTIoYXBpS2V5LCBuZXh0VG9rZW4sIGNvbnRleHQsIG9wdHMpO1xuICBuZXN0ZWRSZXNwLml0ZW1zLnVuc2hpZnQoLi4ucGFyc2VkSXRlbXMpO1xuICByZXR1cm4gbmVzdGVkUmVzcDtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxubWFpbi5jb250aW51ZVJlcSA9IGFzeW5jIGFyZ3MgPT4ge1xuICAvLyBDaGVjayBwYXJhbXNcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpIHx8IGFyZ3MubGVuZ3RoICE9PSA0KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29udGludWF0aW9uIGFycmF5Jyk7XG4gIGlmICghYXJnc1swXSB8fCB0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcGlLZXknKTtcbiAgaWYgKCFhcmdzWzFdIHx8IHR5cGVvZiBhcmdzWzFdICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRva2VuJyk7XG4gIGlmICghYXJnc1syXSB8fCB0eXBlb2YgYXJnc1syXSAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb250ZXh0Jyk7XG4gIGlmICghYXJnc1szXSB8fCB0eXBlb2YgYXJnc1szXSAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvcHRzJyk7XG4gIGlmIChhcmdzWzNdLmxpbWl0ICE9PSBudWxsICYmICFpc05hTihhcmdzWzNdLmxpbWl0KSAmJiBpc0Zpbml0ZShhcmdzWzNdLmxpbWl0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29udGludWVSZXEgb25seSBhbGxvd2VkIGZvciBwYWdlZCByZXF1ZXN0cycpO1xuICB9XG4gIC8vIEVuZm9yY2UgcGFnaW5hdGlvbiBpbmZvcm1hdGlvblxuICBhcmdzWzNdLnBhZ2VzID0gMTtcbiAgYXJnc1szXS5saW1pdCA9IEluZmluaXR5O1xuICByZXR1cm4gcGFyc2VQYWdlMiguLi5hcmdzKTtcbn07XG5cbm1haW4uZ2V0RmlsdGVycyA9IGFzeW5jKHNlYXJjaFN0cmluZywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRzID0gVVRJTC5jaGVja0FyZ3Moc2VhcmNoU3RyaW5nLCBvcHRpb25zKTtcblxuICBjb25zdCByZWYgPSBCQVNFX1NFQVJDSF9VUkwgKyBRUy5lbmNvZGUob3B0cy5xdWVyeSk7XG4gIGNvbnN0IGJvZHkgPSBhd2FpdCBNSU5JR0VUKHJlZiwgb3B0cy5yZXF1ZXN0T3B0aW9ucykudGV4dCgpO1xuICBjb25zdCBwYXJzZWQgPSBVVElMLnBhcnNlQm9keShib2R5KTtcbiAgLy8gUmV0cnkgaWYgb2xkIHJlc3BvbnNlXG4gIGlmICghcGFyc2VkLmpzb24pIHJldHVybiBtYWluLmdldEZpbHRlcnMoc2VhcmNoU3RyaW5nLCBvcHRpb25zKTtcbiAgcmV0dXJuIFVUSUwucGFyc2VGaWx0ZXJzKHBhcnNlZC5qc29uKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytsr/lib/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytsr/lib/parseItem.js":
/*!********************************************!*\
  !*** ./node_modules/ytsr/lib/parseItem.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const UTIL = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/ytsr/lib/utils.js\");\nconst PATH = __webpack_require__(/*! path */ \"path\");\nconst FS = __webpack_require__(/*! fs */ \"fs\");\n\nconst BASE_VIDEO_URL = 'https://www.youtube.com/watch?v=';\nconst prepImg = UTIL.prepImg;\n\nconst parseItem = (item, resp) => {\n  const type = Object.keys(item)[0];\n\n  switch (type) {\n    // Regular Content or Multi-Content\n    case 'videoRenderer':\n      return parseVideo(item[type]);\n    case 'channelRenderer':\n      return parseChannel(item[type]);\n    case 'playlistRenderer':\n      return parsePlaylist(item[type]);\n    case 'radioRenderer':\n      return parseMix(item[type]);\n    case 'gridMovieRenderer':\n      return parseGridMovie(item[type]);\n    case 'gridVideoRenderer':\n      return parseVideo(item[type]);\n    case 'movieRenderer':\n      return parseMovie(item[type]);\n    case 'reelItemRenderer':\n      return parseShort(item[type]);\n    case 'shelfRenderer':\n    case 'richShelfRenderer':\n    case 'reelShelfRenderer':\n      return parseShelf(item[type]);\n    case 'showRenderer':\n      return parseShow(item[type]);\n\n    // Change resp#refinements or resp#resultsFor\n    case 'didYouMeanRenderer':\n      // YouTube advises another query\n      return parseDidYouMeanRenderer(item[type], resp);\n    case 'showingResultsForRenderer':\n      // The results are for another query\n      return parseShowingResultsFor(item, resp);\n    case 'horizontalCardListRenderer':\n      return parseHorizontalCardListRenderer(item[type], resp);\n    case 'includingResultsForRenderer':\n      //  Informational Item we can ignore\n      return null;\n\n    // Message-Types\n    // Skip all messages, since \"no more results\" changes with the language\n    case 'backgroundPromoRenderer':\n    case 'messageRenderer':\n    case 'infoPanelContainerRenderer':\n      return null;\n    case 'clarificationRenderer':\n      return parseClarification(item[type]);\n\n    // Skip Ads for now\n    case 'reelPlayerHeaderRenderer':\n    case 'adSlotRenderer':\n    case 'carouselAdRenderer':\n    case 'searchPyvRenderer':\n    case 'promotedVideoRenderer':\n    case 'promotedSparklesTextSearchRenderer':\n    case 'compactPromotedItemRenderer':\n    case 'promotedSparklesWebRenderer':\n      return null;\n    // Skip emergencyOneboxRenderer (for now?)\n    case 'emergencyOneboxRenderer':\n      // Emergency Notifications like: Thinking about suicide? Call xxxx\n      return null;\n\n    case 'chipCloudRenderer':\n      // Chips are tags associated with a query - ignore for now\n      return null;\n\n    // For debugging purpose\n    case 'debug#previewCardRenderer':\n      return parseHorizontalChannelListItem(item[type]);\n\n    // New type & file without json until now => save\n    default:\n      throw new Error(`type ${type} is not known`);\n  }\n};\n\nconst catchAndLogFunc = (func, params = []) => {\n  if (!Array.isArray(params)) throw new Error('params has to be an (optionally empty) array');\n  try {\n    return func(...params);\n  } catch (e) {\n    const dir = PATH.resolve(__dirname, '../dumps/');\n    const file = PATH.resolve(dir, `${Math.random().toString(36).substr(3)}-${Date.now()}.txt`);\n    const cfg = PATH.resolve(__dirname, '../package.json');\n    const bugsRef = __webpack_require__(\"(rsc)/./node_modules/ytsr/lib sync recursive\")(cfg).bugs.url;\n\n    /* eslint-disable no-console */\n    console.error(e.stack);\n    console.error(`\\n/${'*'.repeat(200)}`);\n    console.error(`failed at func ${func.name}: ${e.message}`);\n    console.error(`pls post the the files in ${dir} to ${bugsRef}`);\n    let info = `os: ${process.platform}-${process.arch}, `;\n    info += `node.js: ${process.version}, `;\n    info += `ytsr: ${(__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/ytsr/package.json\").version)}`;\n    console.error(info);\n    console.error(`${'*'.repeat(200)}\\\\`);\n    /* eslint-enable no-console */\n\n    try {\n      if (!FS.existsSync(dir)) FS.mkdirSync(dir);\n      FS.writeFileSync(file, JSON.stringify(params, null, 2));\n    } catch (e2) {\n      console.warn('Could not write dumps to file:', e2);\n    }\n\n    return null;\n  }\n};\nconst main = module.exports = (...params) => catchAndLogFunc(parseItem, params);\nmain._hidden = { catchAndLogFunc, parseItem };\n\n// TYPES:\nconst parseVideo = obj => {\n  const author = obj.ownerText && obj.ownerText.runs[0];\n  let authorUrl = null;\n  if (author) {\n    authorUrl = author.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n      author.navigationEndpoint.commandMetadata.webCommandMetadata.url;\n  }\n  const badges = Array.isArray(obj.badges) ? obj.badges.map(a => a.metadataBadgeRenderer.label) : [];\n  const isLive = badges.some(b => b === 'LIVE NOW');\n  const upcoming = obj.upcomingEventData ? Number(`${obj.upcomingEventData.startTime}000`) : null;\n  const ctsr = obj.channelThumbnailSupportedRenderers;\n  const authorImg = !ctsr ? { thumbnail: { thumbnails: [] } } : ctsr.channelThumbnailWithLinkRenderer;\n  const isOfficial = !!(obj.ownerBadges && JSON.stringify(obj.ownerBadges).includes('OFFICIAL'));\n  const isVerified = !!(obj.ownerBadges && JSON.stringify(obj.ownerBadges).includes('VERIFIED'));\n  const lengthFallback = obj.thumbnailOverlays.find(x => Object.keys(x)[0] === 'thumbnailOverlayTimeStatusRenderer');\n  const length = obj.lengthText || (lengthFallback && lengthFallback.thumbnailOverlayTimeStatusRenderer.text);\n\n  return {\n    type: 'video',\n    title: UTIL.parseText(obj.title, ''),\n    id: obj.videoId,\n    url: BASE_VIDEO_URL + obj.videoId,\n    bestThumbnail: prepImg(obj.thumbnail.thumbnails)[0],\n    thumbnails: prepImg(obj.thumbnail.thumbnails),\n    isUpcoming: !!upcoming,\n    upcoming,\n    isLive,\n    badges,\n\n    // Author can be null for shows like whBqghP5Oow\n    author: author ? {\n      name: author.text,\n      channelID: author.navigationEndpoint.browseEndpoint.browseId,\n      url: new URL(authorUrl, BASE_VIDEO_URL).toString(),\n      bestAvatar: prepImg(authorImg.thumbnail.thumbnails)[0] || null,\n      avatars: prepImg(authorImg.thumbnail.thumbnails),\n      ownerBadges: Array.isArray(obj.ownerBadges) ? obj.ownerBadges.map(a => a.metadataBadgeRenderer.tooltip) : [],\n      verified: isOfficial || isVerified,\n    } : null,\n\n    description: UTIL.parseText(obj.descriptionSnippet),\n\n    views: !obj.viewCountText ? null : UTIL.parseIntegerFromText(obj.viewCountText),\n    // Duration not provided for live & sometimes with upcoming & sometimes randomly\n    duration: UTIL.parseText(length),\n    // UploadedAt not provided for live & upcoming & sometimes randomly\n    uploadedAt: UTIL.parseText(obj.publishedTimeText),\n  };\n};\n\nconst parseChannel = obj => {\n  const targetUrl = obj.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n    obj.navigationEndpoint.commandMetadata.webCommandMetadata.url;\n  const isOfficial = !!(obj.ownerBadges && JSON.stringify(obj.ownerBadges).includes('OFFICIAL'));\n  const isVerified = !!(obj.ownerBadges && JSON.stringify(obj.ownerBadges).includes('VERIFIED'));\n\n  return {\n    type: 'channel',\n    name: UTIL.parseText(obj.title, ''),\n    channelID: obj.channelId,\n    url: new URL(targetUrl, BASE_VIDEO_URL).toString(),\n    bestAvatar: prepImg(obj.thumbnail.thumbnails)[0],\n    avatars: prepImg(obj.thumbnail.thumbnails),\n    verified: isOfficial || isVerified,\n\n    subscribers: UTIL.parseText(obj.subscriberCountText),\n    descriptionShort: UTIL.parseText(obj.descriptionSnippet),\n    videos: obj.videoCountText ? UTIL.parseIntegerFromText(obj.videoCountText) : null,\n  };\n};\n\nconst parsePlaylist = obj => ({\n  type: 'playlist',\n  title: UTIL.parseText(obj.title, ''),\n  playlistID: obj.playlistId,\n  url: `https://www.youtube.com/playlist?list=${obj.playlistId}`,\n  firstVideo: Array.isArray(obj.videos) && obj.videos.length > 0 ? {\n    id: obj.navigationEndpoint.watchEndpoint.videoId,\n    shortURL: BASE_VIDEO_URL + obj.navigationEndpoint.watchEndpoint.videoId,\n    url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n    title: UTIL.parseText(obj.videos[0].childVideoRenderer.title, ''),\n    length: UTIL.parseText(obj.videos[0].childVideoRenderer.lengthText, ''),\n    thumbnails: prepImg(obj.thumbnails[0].thumbnails),\n    bestThumbnail: prepImg(obj.thumbnails[0].thumbnails)[0],\n  } : null,\n\n  // Some Playlists starting with OL only provide a simple string\n  owner: obj.shortBylineText.simpleText ? null : _parseOwner(obj),\n\n  publishedAt: UTIL.parseText(obj.publishedTimeText),\n  length: Number(obj.videoCount),\n});\n\nconst parseMix = obj => ({\n  type: 'mix',\n  title: UTIL.parseText(obj.title, ''),\n  url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n\n  firstVideo: {\n    id: obj.navigationEndpoint.watchEndpoint.videoId,\n    shortURL: BASE_VIDEO_URL + obj.navigationEndpoint.watchEndpoint.videoId,\n    url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n    text: UTIL.parseText(obj.videos[0].childVideoRenderer.title, ''),\n    length: UTIL.parseText(obj.videos[0].childVideoRenderer.lengthText, ''),\n    thumbnails: prepImg(obj.thumbnail.thumbnails),\n    bestThumbnail: prepImg(obj.thumbnail.thumbnails)[0],\n  },\n});\n\nconst parseDidYouMeanRenderer = (obj, resp) => {\n  // Add as the first item in refinements\n  if (resp && Array.isArray(resp.refinements)) {\n    resp.refinements.unshift({\n      q: UTIL.parseText(obj.correctedQuery, ''),\n      url: new URL(obj.correctedQueryEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n      bestThumbnail: null,\n      thumbnails: null,\n    });\n  }\n  return null;\n};\n\nconst parseShowingResultsFor = (obj, resp) => {\n  // Add as resultsFor\n  const cor = obj.showingResultsForRenderer.correctedQuery || obj.correctedQuery;\n  if (resp) resp.correctedQuery = UTIL.parseText(cor);\n  return null;\n};\n\nconst parseClarification = obj => ({\n  type: 'clarification',\n  title: UTIL.parseText(obj.contentTitle, ''),\n  text: UTIL.parseText(obj.text, ''),\n  sources: [\n    {\n      text: UTIL.parseText(obj.source, ''),\n      url: new URL(obj.endpoint.urlEndpoint.url, BASE_VIDEO_URL).toString(),\n    },\n    !obj.secondarySource ? null : {\n      text: UTIL.parseText(obj.secondarySource, ''),\n      url: new URL(obj.secondaryEndpoint.urlEndpoint.url, BASE_VIDEO_URL).toString(),\n    },\n  ].filter(a => a),\n});\n\nconst parseHorizontalCardListRenderer = (obj, resp) => {\n  const subType = Object.keys(obj.cards[0])[0];\n\n  switch (subType) {\n    case 'searchRefinementCardRenderer':\n      return parseHorizontalRefinements(obj, resp);\n    case 'previewCardRenderer':\n      return parseHorizontalChannelList(obj);\n    default:\n      throw new Error(`subType ${subType} of type horizontalCardListRenderer not known`);\n  }\n};\n\nconst parseHorizontalRefinements = (obj, resp) => {\n  // Add to refinements\n  if (resp && Array.isArray(resp.refinements)) {\n    resp.refinements.push(...obj.cards.map(c => {\n      const targetUrl = c.searchRefinementCardRenderer.searchEndpoint.commandMetadata.webCommandMetadata.url;\n      return {\n        q: UTIL.parseText(c.searchRefinementCardRenderer.query, ''),\n        url: new URL(targetUrl, BASE_VIDEO_URL).toString(),\n        bestThumbnail: prepImg(c.searchRefinementCardRenderer.thumbnail.thumbnails)[0],\n        thumbnails: prepImg(c.searchRefinementCardRenderer.thumbnail.thumbnails),\n      };\n    }));\n  }\n  return null;\n};\n\nconst parseHorizontalChannelList = obj => {\n  if (!JSON.stringify(obj.style).includes('CHANNELS')) {\n    // Not sure if this is always a channel + videos\n    throw new Error(`unknown style in horizontalCardListRenderer`);\n  }\n  return {\n    type: 'horizontalChannelList',\n    title: UTIL.parseText(obj.header.richListHeaderRenderer.title, ''),\n    channels: obj.cards.map(i => parseHorizontalChannelListItem(i.previewCardRenderer)).filter(a => a),\n  };\n};\n\nconst parseHorizontalChannelListItem = obj => {\n  const thumbnailRenderer = obj.header.richListHeaderRenderer.channelThumbnail.channelThumbnailWithLinkRenderer;\n  return {\n    type: 'channelPreview',\n    name: UTIL.parseText(obj.header.richListHeaderRenderer.title, ''),\n    channelID: obj.header.richListHeaderRenderer.endpoint.browseEndpoint.browseId,\n    url: new URL(\n      obj.header.richListHeaderRenderer.endpoint.commandMetadata.webCommandMetadata.url,\n      BASE_VIDEO_URL,\n    ).toString(),\n    bestAvatar: prepImg(thumbnailRenderer.thumbnail.thumbnails)[0],\n    avatars: prepImg(thumbnailRenderer.thumbnail.thumbnails),\n    subscribers: UTIL.parseText(obj.header.richListHeaderRenderer.subtitle, ''),\n    // Type: gridVideoRenderer\n    videos: obj.contents.map(i => parseVideo(i.gridVideoRenderer)).filter(a => a),\n  };\n};\n\nconst parseGridMovie = obj => ({\n  // Movie which can be found in horizontalMovieListRenderer\n  type: 'gridMovie',\n  title: UTIL.parseText(obj.title),\n  videoID: obj.videoId,\n  url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n  bestThumbnail: prepImg(obj.thumbnail.thumbnails)[0],\n  thumbnails: prepImg(obj.thumbnail.thumbnails),\n  duration: UTIL.parseText(obj.lengthText),\n});\n\nconst parseMovie = obj => {\n  // Normalize\n  obj.bottomMetadataItems = (obj.bottomMetadataItems || []).map(x => UTIL.parseText(x));\n  const actorsString = obj.bottomMetadataItems.find(x => x.startsWith('Actors'));\n  const directorsString = obj.bottomMetadataItems.find(x => x.startsWith('Director'));\n\n  return {\n    type: 'movie',\n    title: UTIL.parseText(obj.title, ''),\n    videoID: obj.videoId,\n    url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n    bestThumbnail: prepImg(obj.thumbnail.thumbnails)[0],\n    thumbnails: prepImg(obj.thumbnail.thumbnails),\n\n    owner: _parseOwner(obj),\n    description: UTIL.parseText(obj.descriptionSnippet),\n    meta: UTIL.parseText(obj.topMetadataItems[0], '').split(' Â· '),\n    actors: !actorsString ? [] : actorsString.split(': ')[1].split(', '),\n    directors: !directorsString ? [] : directorsString.split(': ')[1].split(', '),\n    duration: UTIL.parseText(obj.lengthText, ''),\n  };\n};\n\nconst parseShort = obj => {\n  const core = {\n    type: 'short',\n    title: UTIL.parseText(obj.headline, ''),\n    videoID: obj.videoId,\n    url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n    bestThumbnail: prepImg(obj.thumbnail.thumbnails)[0],\n    thumbnails: prepImg(obj.thumbnail.thumbnails),\n    views: UTIL.parseText(obj.viewCountText, ''),\n    published: null,\n    channel: null,\n  };\n  const reelPlayerOverlayRenderer = obj.navigationEndpoint.reelWatchEndpoint.overlay.reelPlayerOverlayRenderer;\n  if (reelPlayerOverlayRenderer.reelPlayerHeaderSupportedRenderers) {\n    const playerHeader = reelPlayerOverlayRenderer.reelPlayerHeaderSupportedRenderers.reelPlayerHeaderRenderer;\n    const channelNavEndpoint = playerHeader.channelTitleText.runs[0].navigationEndpoint;\n    core.published = UTIL.parseText(playerHeader.timestampText, '');\n    core.channel = {\n      name: UTIL.parseText(playerHeader.channelTitleText, ''),\n      channelID: channelNavEndpoint.browseEndpoint.browseId,\n      url: new URL(channelNavEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n      bestAvatar: prepImg(playerHeader.channelThumbnail.thumbnails)[0] || null,\n      avatars: prepImg(playerHeader.channelThumbnail.thumbnails),\n    };\n  }\n  return core;\n};\n\nconst parseShow = obj => {\n  const thumbnails = obj.thumbnailRenderer.showCustomThumbnailRenderer.thumbnail.thumbnails;\n  const owner = _parseOwner(obj);\n  delete owner.ownerBadges;\n  delete owner.verified;\n\n  return {\n    type: 'show',\n    title: UTIL.parseText(obj.title, ''),\n    bestThumbnail: prepImg(thumbnails)[0],\n    thumbnails: prepImg(thumbnails),\n    url: new URL(obj.navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_VIDEO_URL).toString(),\n    videoID: obj.navigationEndpoint.watchEndpoint.videoId,\n    playlistID: obj.navigationEndpoint.watchEndpoint.playlistId,\n    episodes: UTIL.parseIntegerFromText(obj.thumbnailOverlays[0].thumbnailOverlayBottomPanelRenderer.text),\n    owner,\n  };\n};\n\nconst parseShelf = obj => {\n  let rawItems = [];\n  if (Array.isArray(obj.contents)) {\n    rawItems = obj.contents.map(x => x.richItemRenderer.content);\n  } else if (Array.isArray(obj.items)) {\n    rawItems = obj.items;\n  } else {\n    rawItems = (obj.content.verticalListRenderer || obj.content.horizontalMovieListRenderer).items;\n  }\n  // Optional obj.thumbnail is ignored\n  return {\n    type: 'shelf',\n    title: UTIL.parseText(obj.title, 'Show More'),\n    items: rawItems.map(i => parseItem(i)).filter(a => a),\n  };\n};\n\n/**\n * Generalised Method\n *\n * used in Playlist, Movie and Show\n * show does never provide badges thou\n *\n * @param {Object} obj the full Renderer Object provided by YouTube\n * @returns {Object} the parsed owner\n */\nconst _parseOwner = obj => {\n  const owner = (obj.shortBylineText && obj.shortBylineText.runs[0]) ||\n    (obj.longBylineText && obj.longBylineText.runs[0]);\n  const ownerUrl = owner.navigationEndpoint.browseEndpoint.canonicalBaseUrl ||\n    owner.navigationEndpoint.commandMetadata.webCommandMetadata.url;\n  const isOfficial = !!(obj.ownerBadges && JSON.stringify(obj.ownerBadges).includes('OFFICIAL'));\n  const isVerified = !!(obj.ownerBadges && JSON.stringify(obj.ownerBadges).includes('VERIFIED'));\n  const fallbackURL = owner.navigationEndpoint.commandMetadata.webCommandMetadata.url;\n\n  return {\n    name: owner.text,\n    channelID: owner.navigationEndpoint.browseEndpoint.browseId,\n    url: new URL(ownerUrl || fallbackURL, BASE_VIDEO_URL).toString(),\n    ownerBadges: Array.isArray(obj.ownerBadges) ? obj.ownerBadges.map(a => a.metadataBadgeRenderer.tooltip) : [],\n    verified: isOfficial || isVerified,\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRzci9saWIvcGFyc2VJdGVtLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywwREFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0NBQXNDLHFDQUFxQyxHQUFHLFdBQVc7QUFDekY7QUFDQSxvQkFBb0Isb0VBQVEsR0FBRyxDQUFDOztBQUVoQztBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QyxvQ0FBb0MsVUFBVSxJQUFJLFVBQVU7QUFDNUQsK0NBQStDLEtBQUssS0FBSyxRQUFRO0FBQ2pFLHNCQUFzQixpQkFBaUIsR0FBRyxhQUFhO0FBQ3ZELHdCQUF3QixnQkFBZ0I7QUFDeEMscUJBQXFCLDhGQUFrQyxDQUFDO0FBQ3hEO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0NBQWdDO0FBQ3JGO0FBQ0EsOEJBQThCLGFBQWEsbUJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYW50dWJlLy4vbm9kZV9tb2R1bGVzL3l0c3IvbGliL3BhcnNlSXRlbS5qcz84MDc3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFVUSUwgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5jb25zdCBQQVRIID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgRlMgPSByZXF1aXJlKCdmcycpO1xuXG5jb25zdCBCQVNFX1ZJREVPX1VSTCA9ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PSc7XG5jb25zdCBwcmVwSW1nID0gVVRJTC5wcmVwSW1nO1xuXG5jb25zdCBwYXJzZUl0ZW0gPSAoaXRlbSwgcmVzcCkgPT4ge1xuICBjb25zdCB0eXBlID0gT2JqZWN0LmtleXMoaXRlbSlbMF07XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gUmVndWxhciBDb250ZW50IG9yIE11bHRpLUNvbnRlbnRcbiAgICBjYXNlICd2aWRlb1JlbmRlcmVyJzpcbiAgICAgIHJldHVybiBwYXJzZVZpZGVvKGl0ZW1bdHlwZV0pO1xuICAgIGNhc2UgJ2NoYW5uZWxSZW5kZXJlcic6XG4gICAgICByZXR1cm4gcGFyc2VDaGFubmVsKGl0ZW1bdHlwZV0pO1xuICAgIGNhc2UgJ3BsYXlsaXN0UmVuZGVyZXInOlxuICAgICAgcmV0dXJuIHBhcnNlUGxheWxpc3QoaXRlbVt0eXBlXSk7XG4gICAgY2FzZSAncmFkaW9SZW5kZXJlcic6XG4gICAgICByZXR1cm4gcGFyc2VNaXgoaXRlbVt0eXBlXSk7XG4gICAgY2FzZSAnZ3JpZE1vdmllUmVuZGVyZXInOlxuICAgICAgcmV0dXJuIHBhcnNlR3JpZE1vdmllKGl0ZW1bdHlwZV0pO1xuICAgIGNhc2UgJ2dyaWRWaWRlb1JlbmRlcmVyJzpcbiAgICAgIHJldHVybiBwYXJzZVZpZGVvKGl0ZW1bdHlwZV0pO1xuICAgIGNhc2UgJ21vdmllUmVuZGVyZXInOlxuICAgICAgcmV0dXJuIHBhcnNlTW92aWUoaXRlbVt0eXBlXSk7XG4gICAgY2FzZSAncmVlbEl0ZW1SZW5kZXJlcic6XG4gICAgICByZXR1cm4gcGFyc2VTaG9ydChpdGVtW3R5cGVdKTtcbiAgICBjYXNlICdzaGVsZlJlbmRlcmVyJzpcbiAgICBjYXNlICdyaWNoU2hlbGZSZW5kZXJlcic6XG4gICAgY2FzZSAncmVlbFNoZWxmUmVuZGVyZXInOlxuICAgICAgcmV0dXJuIHBhcnNlU2hlbGYoaXRlbVt0eXBlXSk7XG4gICAgY2FzZSAnc2hvd1JlbmRlcmVyJzpcbiAgICAgIHJldHVybiBwYXJzZVNob3coaXRlbVt0eXBlXSk7XG5cbiAgICAvLyBDaGFuZ2UgcmVzcCNyZWZpbmVtZW50cyBvciByZXNwI3Jlc3VsdHNGb3JcbiAgICBjYXNlICdkaWRZb3VNZWFuUmVuZGVyZXInOlxuICAgICAgLy8gWW91VHViZSBhZHZpc2VzIGFub3RoZXIgcXVlcnlcbiAgICAgIHJldHVybiBwYXJzZURpZFlvdU1lYW5SZW5kZXJlcihpdGVtW3R5cGVdLCByZXNwKTtcbiAgICBjYXNlICdzaG93aW5nUmVzdWx0c0ZvclJlbmRlcmVyJzpcbiAgICAgIC8vIFRoZSByZXN1bHRzIGFyZSBmb3IgYW5vdGhlciBxdWVyeVxuICAgICAgcmV0dXJuIHBhcnNlU2hvd2luZ1Jlc3VsdHNGb3IoaXRlbSwgcmVzcCk7XG4gICAgY2FzZSAnaG9yaXpvbnRhbENhcmRMaXN0UmVuZGVyZXInOlxuICAgICAgcmV0dXJuIHBhcnNlSG9yaXpvbnRhbENhcmRMaXN0UmVuZGVyZXIoaXRlbVt0eXBlXSwgcmVzcCk7XG4gICAgY2FzZSAnaW5jbHVkaW5nUmVzdWx0c0ZvclJlbmRlcmVyJzpcbiAgICAgIC8vICBJbmZvcm1hdGlvbmFsIEl0ZW0gd2UgY2FuIGlnbm9yZVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBNZXNzYWdlLVR5cGVzXG4gICAgLy8gU2tpcCBhbGwgbWVzc2FnZXMsIHNpbmNlIFwibm8gbW9yZSByZXN1bHRzXCIgY2hhbmdlcyB3aXRoIHRoZSBsYW5ndWFnZVxuICAgIGNhc2UgJ2JhY2tncm91bmRQcm9tb1JlbmRlcmVyJzpcbiAgICBjYXNlICdtZXNzYWdlUmVuZGVyZXInOlxuICAgIGNhc2UgJ2luZm9QYW5lbENvbnRhaW5lclJlbmRlcmVyJzpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ2NsYXJpZmljYXRpb25SZW5kZXJlcic6XG4gICAgICByZXR1cm4gcGFyc2VDbGFyaWZpY2F0aW9uKGl0ZW1bdHlwZV0pO1xuXG4gICAgLy8gU2tpcCBBZHMgZm9yIG5vd1xuICAgIGNhc2UgJ3JlZWxQbGF5ZXJIZWFkZXJSZW5kZXJlcic6XG4gICAgY2FzZSAnYWRTbG90UmVuZGVyZXInOlxuICAgIGNhc2UgJ2Nhcm91c2VsQWRSZW5kZXJlcic6XG4gICAgY2FzZSAnc2VhcmNoUHl2UmVuZGVyZXInOlxuICAgIGNhc2UgJ3Byb21vdGVkVmlkZW9SZW5kZXJlcic6XG4gICAgY2FzZSAncHJvbW90ZWRTcGFya2xlc1RleHRTZWFyY2hSZW5kZXJlcic6XG4gICAgY2FzZSAnY29tcGFjdFByb21vdGVkSXRlbVJlbmRlcmVyJzpcbiAgICBjYXNlICdwcm9tb3RlZFNwYXJrbGVzV2ViUmVuZGVyZXInOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gU2tpcCBlbWVyZ2VuY3lPbmVib3hSZW5kZXJlciAoZm9yIG5vdz8pXG4gICAgY2FzZSAnZW1lcmdlbmN5T25lYm94UmVuZGVyZXInOlxuICAgICAgLy8gRW1lcmdlbmN5IE5vdGlmaWNhdGlvbnMgbGlrZTogVGhpbmtpbmcgYWJvdXQgc3VpY2lkZT8gQ2FsbCB4eHh4XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ2NoaXBDbG91ZFJlbmRlcmVyJzpcbiAgICAgIC8vIENoaXBzIGFyZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCBhIHF1ZXJ5IC0gaWdub3JlIGZvciBub3dcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgLy8gRm9yIGRlYnVnZ2luZyBwdXJwb3NlXG4gICAgY2FzZSAnZGVidWcjcHJldmlld0NhcmRSZW5kZXJlcic6XG4gICAgICByZXR1cm4gcGFyc2VIb3Jpem9udGFsQ2hhbm5lbExpc3RJdGVtKGl0ZW1bdHlwZV0pO1xuXG4gICAgLy8gTmV3IHR5cGUgJiBmaWxlIHdpdGhvdXQganNvbiB1bnRpbCBub3cgPT4gc2F2ZVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgJHt0eXBlfSBpcyBub3Qga25vd25gKTtcbiAgfVxufTtcblxuY29uc3QgY2F0Y2hBbmRMb2dGdW5jID0gKGZ1bmMsIHBhcmFtcyA9IFtdKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtcyBoYXMgdG8gYmUgYW4gKG9wdGlvbmFsbHkgZW1wdHkpIGFycmF5Jyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoLi4ucGFyYW1zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGRpciA9IFBBVEgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi9kdW1wcy8nKTtcbiAgICBjb25zdCBmaWxlID0gUEFUSC5yZXNvbHZlKGRpciwgYCR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDMpfS0ke0RhdGUubm93KCl9LnR4dGApO1xuICAgIGNvbnN0IGNmZyA9IFBBVEgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi9wYWNrYWdlLmpzb24nKTtcbiAgICBjb25zdCBidWdzUmVmID0gcmVxdWlyZShjZmcpLmJ1Z3MudXJsO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG4gICAgY29uc29sZS5lcnJvcihgXFxuLyR7JyonLnJlcGVhdCgyMDApfWApO1xuICAgIGNvbnNvbGUuZXJyb3IoYGZhaWxlZCBhdCBmdW5jICR7ZnVuYy5uYW1lfTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgY29uc29sZS5lcnJvcihgcGxzIHBvc3QgdGhlIHRoZSBmaWxlcyBpbiAke2Rpcn0gdG8gJHtidWdzUmVmfWApO1xuICAgIGxldCBpbmZvID0gYG9zOiAke3Byb2Nlc3MucGxhdGZvcm19LSR7cHJvY2Vzcy5hcmNofSwgYDtcbiAgICBpbmZvICs9IGBub2RlLmpzOiAke3Byb2Nlc3MudmVyc2lvbn0sIGA7XG4gICAgaW5mbyArPSBgeXRzcjogJHtyZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9ufWA7XG4gICAgY29uc29sZS5lcnJvcihpbmZvKTtcbiAgICBjb25zb2xlLmVycm9yKGAkeycqJy5yZXBlYXQoMjAwKX1cXFxcYCk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFGUy5leGlzdHNTeW5jKGRpcikpIEZTLm1rZGlyU3luYyhkaXIpO1xuICAgICAgRlMud3JpdGVGaWxlU3luYyhmaWxlLCBKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDIpKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgd3JpdGUgZHVtcHMgdG8gZmlsZTonLCBlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5jb25zdCBtYWluID0gbW9kdWxlLmV4cG9ydHMgPSAoLi4ucGFyYW1zKSA9PiBjYXRjaEFuZExvZ0Z1bmMocGFyc2VJdGVtLCBwYXJhbXMpO1xubWFpbi5faGlkZGVuID0geyBjYXRjaEFuZExvZ0Z1bmMsIHBhcnNlSXRlbSB9O1xuXG4vLyBUWVBFUzpcbmNvbnN0IHBhcnNlVmlkZW8gPSBvYmogPT4ge1xuICBjb25zdCBhdXRob3IgPSBvYmoub3duZXJUZXh0ICYmIG9iai5vd25lclRleHQucnVuc1swXTtcbiAgbGV0IGF1dGhvclVybCA9IG51bGw7XG4gIGlmIChhdXRob3IpIHtcbiAgICBhdXRob3JVcmwgPSBhdXRob3IubmF2aWdhdGlvbkVuZHBvaW50LmJyb3dzZUVuZHBvaW50LmNhbm9uaWNhbEJhc2VVcmwgfHxcbiAgICAgIGF1dGhvci5uYXZpZ2F0aW9uRW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmw7XG4gIH1cbiAgY29uc3QgYmFkZ2VzID0gQXJyYXkuaXNBcnJheShvYmouYmFkZ2VzKSA/IG9iai5iYWRnZXMubWFwKGEgPT4gYS5tZXRhZGF0YUJhZGdlUmVuZGVyZXIubGFiZWwpIDogW107XG4gIGNvbnN0IGlzTGl2ZSA9IGJhZGdlcy5zb21lKGIgPT4gYiA9PT0gJ0xJVkUgTk9XJyk7XG4gIGNvbnN0IHVwY29taW5nID0gb2JqLnVwY29taW5nRXZlbnREYXRhID8gTnVtYmVyKGAke29iai51cGNvbWluZ0V2ZW50RGF0YS5zdGFydFRpbWV9MDAwYCkgOiBudWxsO1xuICBjb25zdCBjdHNyID0gb2JqLmNoYW5uZWxUaHVtYm5haWxTdXBwb3J0ZWRSZW5kZXJlcnM7XG4gIGNvbnN0IGF1dGhvckltZyA9ICFjdHNyID8geyB0aHVtYm5haWw6IHsgdGh1bWJuYWlsczogW10gfSB9IDogY3Rzci5jaGFubmVsVGh1bWJuYWlsV2l0aExpbmtSZW5kZXJlcjtcbiAgY29uc3QgaXNPZmZpY2lhbCA9ICEhKG9iai5vd25lckJhZGdlcyAmJiBKU09OLnN0cmluZ2lmeShvYmoub3duZXJCYWRnZXMpLmluY2x1ZGVzKCdPRkZJQ0lBTCcpKTtcbiAgY29uc3QgaXNWZXJpZmllZCA9ICEhKG9iai5vd25lckJhZGdlcyAmJiBKU09OLnN0cmluZ2lmeShvYmoub3duZXJCYWRnZXMpLmluY2x1ZGVzKCdWRVJJRklFRCcpKTtcbiAgY29uc3QgbGVuZ3RoRmFsbGJhY2sgPSBvYmoudGh1bWJuYWlsT3ZlcmxheXMuZmluZCh4ID0+IE9iamVjdC5rZXlzKHgpWzBdID09PSAndGh1bWJuYWlsT3ZlcmxheVRpbWVTdGF0dXNSZW5kZXJlcicpO1xuICBjb25zdCBsZW5ndGggPSBvYmoubGVuZ3RoVGV4dCB8fCAobGVuZ3RoRmFsbGJhY2sgJiYgbGVuZ3RoRmFsbGJhY2sudGh1bWJuYWlsT3ZlcmxheVRpbWVTdGF0dXNSZW5kZXJlci50ZXh0KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICd2aWRlbycsXG4gICAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai50aXRsZSwgJycpLFxuICAgIGlkOiBvYmoudmlkZW9JZCxcbiAgICB1cmw6IEJBU0VfVklERU9fVVJMICsgb2JqLnZpZGVvSWQsXG4gICAgYmVzdFRodW1ibmFpbDogcHJlcEltZyhvYmoudGh1bWJuYWlsLnRodW1ibmFpbHMpWzBdLFxuICAgIHRodW1ibmFpbHM6IHByZXBJbWcob2JqLnRodW1ibmFpbC50aHVtYm5haWxzKSxcbiAgICBpc1VwY29taW5nOiAhIXVwY29taW5nLFxuICAgIHVwY29taW5nLFxuICAgIGlzTGl2ZSxcbiAgICBiYWRnZXMsXG5cbiAgICAvLyBBdXRob3IgY2FuIGJlIG51bGwgZm9yIHNob3dzIGxpa2Ugd2hCcWdoUDVPb3dcbiAgICBhdXRob3I6IGF1dGhvciA/IHtcbiAgICAgIG5hbWU6IGF1dGhvci50ZXh0LFxuICAgICAgY2hhbm5lbElEOiBhdXRob3IubmF2aWdhdGlvbkVuZHBvaW50LmJyb3dzZUVuZHBvaW50LmJyb3dzZUlkLFxuICAgICAgdXJsOiBuZXcgVVJMKGF1dGhvclVybCwgQkFTRV9WSURFT19VUkwpLnRvU3RyaW5nKCksXG4gICAgICBiZXN0QXZhdGFyOiBwcmVwSW1nKGF1dGhvckltZy50aHVtYm5haWwudGh1bWJuYWlscylbMF0gfHwgbnVsbCxcbiAgICAgIGF2YXRhcnM6IHByZXBJbWcoYXV0aG9ySW1nLnRodW1ibmFpbC50aHVtYm5haWxzKSxcbiAgICAgIG93bmVyQmFkZ2VzOiBBcnJheS5pc0FycmF5KG9iai5vd25lckJhZGdlcykgPyBvYmoub3duZXJCYWRnZXMubWFwKGEgPT4gYS5tZXRhZGF0YUJhZGdlUmVuZGVyZXIudG9vbHRpcCkgOiBbXSxcbiAgICAgIHZlcmlmaWVkOiBpc09mZmljaWFsIHx8IGlzVmVyaWZpZWQsXG4gICAgfSA6IG51bGwsXG5cbiAgICBkZXNjcmlwdGlvbjogVVRJTC5wYXJzZVRleHQob2JqLmRlc2NyaXB0aW9uU25pcHBldCksXG5cbiAgICB2aWV3czogIW9iai52aWV3Q291bnRUZXh0ID8gbnVsbCA6IFVUSUwucGFyc2VJbnRlZ2VyRnJvbVRleHQob2JqLnZpZXdDb3VudFRleHQpLFxuICAgIC8vIER1cmF0aW9uIG5vdCBwcm92aWRlZCBmb3IgbGl2ZSAmIHNvbWV0aW1lcyB3aXRoIHVwY29taW5nICYgc29tZXRpbWVzIHJhbmRvbWx5XG4gICAgZHVyYXRpb246IFVUSUwucGFyc2VUZXh0KGxlbmd0aCksXG4gICAgLy8gVXBsb2FkZWRBdCBub3QgcHJvdmlkZWQgZm9yIGxpdmUgJiB1cGNvbWluZyAmIHNvbWV0aW1lcyByYW5kb21seVxuICAgIHVwbG9hZGVkQXQ6IFVUSUwucGFyc2VUZXh0KG9iai5wdWJsaXNoZWRUaW1lVGV4dCksXG4gIH07XG59O1xuXG5jb25zdCBwYXJzZUNoYW5uZWwgPSBvYmogPT4ge1xuICBjb25zdCB0YXJnZXRVcmwgPSBvYmoubmF2aWdhdGlvbkVuZHBvaW50LmJyb3dzZUVuZHBvaW50LmNhbm9uaWNhbEJhc2VVcmwgfHxcbiAgICBvYmoubmF2aWdhdGlvbkVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsO1xuICBjb25zdCBpc09mZmljaWFsID0gISEob2JqLm93bmVyQmFkZ2VzICYmIEpTT04uc3RyaW5naWZ5KG9iai5vd25lckJhZGdlcykuaW5jbHVkZXMoJ09GRklDSUFMJykpO1xuICBjb25zdCBpc1ZlcmlmaWVkID0gISEob2JqLm93bmVyQmFkZ2VzICYmIEpTT04uc3RyaW5naWZ5KG9iai5vd25lckJhZGdlcykuaW5jbHVkZXMoJ1ZFUklGSUVEJykpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2NoYW5uZWwnLFxuICAgIG5hbWU6IFVUSUwucGFyc2VUZXh0KG9iai50aXRsZSwgJycpLFxuICAgIGNoYW5uZWxJRDogb2JqLmNoYW5uZWxJZCxcbiAgICB1cmw6IG5ldyBVUkwodGFyZ2V0VXJsLCBCQVNFX1ZJREVPX1VSTCkudG9TdHJpbmcoKSxcbiAgICBiZXN0QXZhdGFyOiBwcmVwSW1nKG9iai50aHVtYm5haWwudGh1bWJuYWlscylbMF0sXG4gICAgYXZhdGFyczogcHJlcEltZyhvYmoudGh1bWJuYWlsLnRodW1ibmFpbHMpLFxuICAgIHZlcmlmaWVkOiBpc09mZmljaWFsIHx8IGlzVmVyaWZpZWQsXG5cbiAgICBzdWJzY3JpYmVyczogVVRJTC5wYXJzZVRleHQob2JqLnN1YnNjcmliZXJDb3VudFRleHQpLFxuICAgIGRlc2NyaXB0aW9uU2hvcnQ6IFVUSUwucGFyc2VUZXh0KG9iai5kZXNjcmlwdGlvblNuaXBwZXQpLFxuICAgIHZpZGVvczogb2JqLnZpZGVvQ291bnRUZXh0ID8gVVRJTC5wYXJzZUludGVnZXJGcm9tVGV4dChvYmoudmlkZW9Db3VudFRleHQpIDogbnVsbCxcbiAgfTtcbn07XG5cbmNvbnN0IHBhcnNlUGxheWxpc3QgPSBvYmogPT4gKHtcbiAgdHlwZTogJ3BsYXlsaXN0JyxcbiAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai50aXRsZSwgJycpLFxuICBwbGF5bGlzdElEOiBvYmoucGxheWxpc3RJZCxcbiAgdXJsOiBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vcGxheWxpc3Q/bGlzdD0ke29iai5wbGF5bGlzdElkfWAsXG4gIGZpcnN0VmlkZW86IEFycmF5LmlzQXJyYXkob2JqLnZpZGVvcykgJiYgb2JqLnZpZGVvcy5sZW5ndGggPiAwID8ge1xuICAgIGlkOiBvYmoubmF2aWdhdGlvbkVuZHBvaW50LndhdGNoRW5kcG9pbnQudmlkZW9JZCxcbiAgICBzaG9ydFVSTDogQkFTRV9WSURFT19VUkwgKyBvYmoubmF2aWdhdGlvbkVuZHBvaW50LndhdGNoRW5kcG9pbnQudmlkZW9JZCxcbiAgICB1cmw6IG5ldyBVUkwob2JqLm5hdmlnYXRpb25FbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybCwgQkFTRV9WSURFT19VUkwpLnRvU3RyaW5nKCksXG4gICAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai52aWRlb3NbMF0uY2hpbGRWaWRlb1JlbmRlcmVyLnRpdGxlLCAnJyksXG4gICAgbGVuZ3RoOiBVVElMLnBhcnNlVGV4dChvYmoudmlkZW9zWzBdLmNoaWxkVmlkZW9SZW5kZXJlci5sZW5ndGhUZXh0LCAnJyksXG4gICAgdGh1bWJuYWlsczogcHJlcEltZyhvYmoudGh1bWJuYWlsc1swXS50aHVtYm5haWxzKSxcbiAgICBiZXN0VGh1bWJuYWlsOiBwcmVwSW1nKG9iai50aHVtYm5haWxzWzBdLnRodW1ibmFpbHMpWzBdLFxuICB9IDogbnVsbCxcblxuICAvLyBTb21lIFBsYXlsaXN0cyBzdGFydGluZyB3aXRoIE9MIG9ubHkgcHJvdmlkZSBhIHNpbXBsZSBzdHJpbmdcbiAgb3duZXI6IG9iai5zaG9ydEJ5bGluZVRleHQuc2ltcGxlVGV4dCA/IG51bGwgOiBfcGFyc2VPd25lcihvYmopLFxuXG4gIHB1Ymxpc2hlZEF0OiBVVElMLnBhcnNlVGV4dChvYmoucHVibGlzaGVkVGltZVRleHQpLFxuICBsZW5ndGg6IE51bWJlcihvYmoudmlkZW9Db3VudCksXG59KTtcblxuY29uc3QgcGFyc2VNaXggPSBvYmogPT4gKHtcbiAgdHlwZTogJ21peCcsXG4gIHRpdGxlOiBVVElMLnBhcnNlVGV4dChvYmoudGl0bGUsICcnKSxcbiAgdXJsOiBuZXcgVVJMKG9iai5uYXZpZ2F0aW9uRW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuXG4gIGZpcnN0VmlkZW86IHtcbiAgICBpZDogb2JqLm5hdmlnYXRpb25FbmRwb2ludC53YXRjaEVuZHBvaW50LnZpZGVvSWQsXG4gICAgc2hvcnRVUkw6IEJBU0VfVklERU9fVVJMICsgb2JqLm5hdmlnYXRpb25FbmRwb2ludC53YXRjaEVuZHBvaW50LnZpZGVvSWQsXG4gICAgdXJsOiBuZXcgVVJMKG9iai5uYXZpZ2F0aW9uRW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuICAgIHRleHQ6IFVUSUwucGFyc2VUZXh0KG9iai52aWRlb3NbMF0uY2hpbGRWaWRlb1JlbmRlcmVyLnRpdGxlLCAnJyksXG4gICAgbGVuZ3RoOiBVVElMLnBhcnNlVGV4dChvYmoudmlkZW9zWzBdLmNoaWxkVmlkZW9SZW5kZXJlci5sZW5ndGhUZXh0LCAnJyksXG4gICAgdGh1bWJuYWlsczogcHJlcEltZyhvYmoudGh1bWJuYWlsLnRodW1ibmFpbHMpLFxuICAgIGJlc3RUaHVtYm5haWw6IHByZXBJbWcob2JqLnRodW1ibmFpbC50aHVtYm5haWxzKVswXSxcbiAgfSxcbn0pO1xuXG5jb25zdCBwYXJzZURpZFlvdU1lYW5SZW5kZXJlciA9IChvYmosIHJlc3ApID0+IHtcbiAgLy8gQWRkIGFzIHRoZSBmaXJzdCBpdGVtIGluIHJlZmluZW1lbnRzXG4gIGlmIChyZXNwICYmIEFycmF5LmlzQXJyYXkocmVzcC5yZWZpbmVtZW50cykpIHtcbiAgICByZXNwLnJlZmluZW1lbnRzLnVuc2hpZnQoe1xuICAgICAgcTogVVRJTC5wYXJzZVRleHQob2JqLmNvcnJlY3RlZFF1ZXJ5LCAnJyksXG4gICAgICB1cmw6IG5ldyBVUkwob2JqLmNvcnJlY3RlZFF1ZXJ5RW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuICAgICAgYmVzdFRodW1ibmFpbDogbnVsbCxcbiAgICAgIHRodW1ibmFpbHM6IG51bGwsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBwYXJzZVNob3dpbmdSZXN1bHRzRm9yID0gKG9iaiwgcmVzcCkgPT4ge1xuICAvLyBBZGQgYXMgcmVzdWx0c0ZvclxuICBjb25zdCBjb3IgPSBvYmouc2hvd2luZ1Jlc3VsdHNGb3JSZW5kZXJlci5jb3JyZWN0ZWRRdWVyeSB8fCBvYmouY29ycmVjdGVkUXVlcnk7XG4gIGlmIChyZXNwKSByZXNwLmNvcnJlY3RlZFF1ZXJ5ID0gVVRJTC5wYXJzZVRleHQoY29yKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBwYXJzZUNsYXJpZmljYXRpb24gPSBvYmogPT4gKHtcbiAgdHlwZTogJ2NsYXJpZmljYXRpb24nLFxuICB0aXRsZTogVVRJTC5wYXJzZVRleHQob2JqLmNvbnRlbnRUaXRsZSwgJycpLFxuICB0ZXh0OiBVVElMLnBhcnNlVGV4dChvYmoudGV4dCwgJycpLFxuICBzb3VyY2VzOiBbXG4gICAge1xuICAgICAgdGV4dDogVVRJTC5wYXJzZVRleHQob2JqLnNvdXJjZSwgJycpLFxuICAgICAgdXJsOiBuZXcgVVJMKG9iai5lbmRwb2ludC51cmxFbmRwb2ludC51cmwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuICAgIH0sXG4gICAgIW9iai5zZWNvbmRhcnlTb3VyY2UgPyBudWxsIDoge1xuICAgICAgdGV4dDogVVRJTC5wYXJzZVRleHQob2JqLnNlY29uZGFyeVNvdXJjZSwgJycpLFxuICAgICAgdXJsOiBuZXcgVVJMKG9iai5zZWNvbmRhcnlFbmRwb2ludC51cmxFbmRwb2ludC51cmwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuICAgIH0sXG4gIF0uZmlsdGVyKGEgPT4gYSksXG59KTtcblxuY29uc3QgcGFyc2VIb3Jpem9udGFsQ2FyZExpc3RSZW5kZXJlciA9IChvYmosIHJlc3ApID0+IHtcbiAgY29uc3Qgc3ViVHlwZSA9IE9iamVjdC5rZXlzKG9iai5jYXJkc1swXSlbMF07XG5cbiAgc3dpdGNoIChzdWJUeXBlKSB7XG4gICAgY2FzZSAnc2VhcmNoUmVmaW5lbWVudENhcmRSZW5kZXJlcic6XG4gICAgICByZXR1cm4gcGFyc2VIb3Jpem9udGFsUmVmaW5lbWVudHMob2JqLCByZXNwKTtcbiAgICBjYXNlICdwcmV2aWV3Q2FyZFJlbmRlcmVyJzpcbiAgICAgIHJldHVybiBwYXJzZUhvcml6b250YWxDaGFubmVsTGlzdChvYmopO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1YlR5cGUgJHtzdWJUeXBlfSBvZiB0eXBlIGhvcml6b250YWxDYXJkTGlzdFJlbmRlcmVyIG5vdCBrbm93bmApO1xuICB9XG59O1xuXG5jb25zdCBwYXJzZUhvcml6b250YWxSZWZpbmVtZW50cyA9IChvYmosIHJlc3ApID0+IHtcbiAgLy8gQWRkIHRvIHJlZmluZW1lbnRzXG4gIGlmIChyZXNwICYmIEFycmF5LmlzQXJyYXkocmVzcC5yZWZpbmVtZW50cykpIHtcbiAgICByZXNwLnJlZmluZW1lbnRzLnB1c2goLi4ub2JqLmNhcmRzLm1hcChjID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFVybCA9IGMuc2VhcmNoUmVmaW5lbWVudENhcmRSZW5kZXJlci5zZWFyY2hFbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHE6IFVUSUwucGFyc2VUZXh0KGMuc2VhcmNoUmVmaW5lbWVudENhcmRSZW5kZXJlci5xdWVyeSwgJycpLFxuICAgICAgICB1cmw6IG5ldyBVUkwodGFyZ2V0VXJsLCBCQVNFX1ZJREVPX1VSTCkudG9TdHJpbmcoKSxcbiAgICAgICAgYmVzdFRodW1ibmFpbDogcHJlcEltZyhjLnNlYXJjaFJlZmluZW1lbnRDYXJkUmVuZGVyZXIudGh1bWJuYWlsLnRodW1ibmFpbHMpWzBdLFxuICAgICAgICB0aHVtYm5haWxzOiBwcmVwSW1nKGMuc2VhcmNoUmVmaW5lbWVudENhcmRSZW5kZXJlci50aHVtYm5haWwudGh1bWJuYWlscyksXG4gICAgICB9O1xuICAgIH0pKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHBhcnNlSG9yaXpvbnRhbENoYW5uZWxMaXN0ID0gb2JqID0+IHtcbiAgaWYgKCFKU09OLnN0cmluZ2lmeShvYmouc3R5bGUpLmluY2x1ZGVzKCdDSEFOTkVMUycpKSB7XG4gICAgLy8gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgYSBjaGFubmVsICsgdmlkZW9zXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHN0eWxlIGluIGhvcml6b250YWxDYXJkTGlzdFJlbmRlcmVyYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnaG9yaXpvbnRhbENoYW5uZWxMaXN0JyxcbiAgICB0aXRsZTogVVRJTC5wYXJzZVRleHQob2JqLmhlYWRlci5yaWNoTGlzdEhlYWRlclJlbmRlcmVyLnRpdGxlLCAnJyksXG4gICAgY2hhbm5lbHM6IG9iai5jYXJkcy5tYXAoaSA9PiBwYXJzZUhvcml6b250YWxDaGFubmVsTGlzdEl0ZW0oaS5wcmV2aWV3Q2FyZFJlbmRlcmVyKSkuZmlsdGVyKGEgPT4gYSksXG4gIH07XG59O1xuXG5jb25zdCBwYXJzZUhvcml6b250YWxDaGFubmVsTGlzdEl0ZW0gPSBvYmogPT4ge1xuICBjb25zdCB0aHVtYm5haWxSZW5kZXJlciA9IG9iai5oZWFkZXIucmljaExpc3RIZWFkZXJSZW5kZXJlci5jaGFubmVsVGh1bWJuYWlsLmNoYW5uZWxUaHVtYm5haWxXaXRoTGlua1JlbmRlcmVyO1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdjaGFubmVsUHJldmlldycsXG4gICAgbmFtZTogVVRJTC5wYXJzZVRleHQob2JqLmhlYWRlci5yaWNoTGlzdEhlYWRlclJlbmRlcmVyLnRpdGxlLCAnJyksXG4gICAgY2hhbm5lbElEOiBvYmouaGVhZGVyLnJpY2hMaXN0SGVhZGVyUmVuZGVyZXIuZW5kcG9pbnQuYnJvd3NlRW5kcG9pbnQuYnJvd3NlSWQsXG4gICAgdXJsOiBuZXcgVVJMKFxuICAgICAgb2JqLmhlYWRlci5yaWNoTGlzdEhlYWRlclJlbmRlcmVyLmVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLFxuICAgICAgQkFTRV9WSURFT19VUkwsXG4gICAgKS50b1N0cmluZygpLFxuICAgIGJlc3RBdmF0YXI6IHByZXBJbWcodGh1bWJuYWlsUmVuZGVyZXIudGh1bWJuYWlsLnRodW1ibmFpbHMpWzBdLFxuICAgIGF2YXRhcnM6IHByZXBJbWcodGh1bWJuYWlsUmVuZGVyZXIudGh1bWJuYWlsLnRodW1ibmFpbHMpLFxuICAgIHN1YnNjcmliZXJzOiBVVElMLnBhcnNlVGV4dChvYmouaGVhZGVyLnJpY2hMaXN0SGVhZGVyUmVuZGVyZXIuc3VidGl0bGUsICcnKSxcbiAgICAvLyBUeXBlOiBncmlkVmlkZW9SZW5kZXJlclxuICAgIHZpZGVvczogb2JqLmNvbnRlbnRzLm1hcChpID0+IHBhcnNlVmlkZW8oaS5ncmlkVmlkZW9SZW5kZXJlcikpLmZpbHRlcihhID0+IGEpLFxuICB9O1xufTtcblxuY29uc3QgcGFyc2VHcmlkTW92aWUgPSBvYmogPT4gKHtcbiAgLy8gTW92aWUgd2hpY2ggY2FuIGJlIGZvdW5kIGluIGhvcml6b250YWxNb3ZpZUxpc3RSZW5kZXJlclxuICB0eXBlOiAnZ3JpZE1vdmllJyxcbiAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai50aXRsZSksXG4gIHZpZGVvSUQ6IG9iai52aWRlb0lkLFxuICB1cmw6IG5ldyBVUkwob2JqLm5hdmlnYXRpb25FbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybCwgQkFTRV9WSURFT19VUkwpLnRvU3RyaW5nKCksXG4gIGJlc3RUaHVtYm5haWw6IHByZXBJbWcob2JqLnRodW1ibmFpbC50aHVtYm5haWxzKVswXSxcbiAgdGh1bWJuYWlsczogcHJlcEltZyhvYmoudGh1bWJuYWlsLnRodW1ibmFpbHMpLFxuICBkdXJhdGlvbjogVVRJTC5wYXJzZVRleHQob2JqLmxlbmd0aFRleHQpLFxufSk7XG5cbmNvbnN0IHBhcnNlTW92aWUgPSBvYmogPT4ge1xuICAvLyBOb3JtYWxpemVcbiAgb2JqLmJvdHRvbU1ldGFkYXRhSXRlbXMgPSAob2JqLmJvdHRvbU1ldGFkYXRhSXRlbXMgfHwgW10pLm1hcCh4ID0+IFVUSUwucGFyc2VUZXh0KHgpKTtcbiAgY29uc3QgYWN0b3JzU3RyaW5nID0gb2JqLmJvdHRvbU1ldGFkYXRhSXRlbXMuZmluZCh4ID0+IHguc3RhcnRzV2l0aCgnQWN0b3JzJykpO1xuICBjb25zdCBkaXJlY3RvcnNTdHJpbmcgPSBvYmouYm90dG9tTWV0YWRhdGFJdGVtcy5maW5kKHggPT4geC5zdGFydHNXaXRoKCdEaXJlY3RvcicpKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdtb3ZpZScsXG4gICAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai50aXRsZSwgJycpLFxuICAgIHZpZGVvSUQ6IG9iai52aWRlb0lkLFxuICAgIHVybDogbmV3IFVSTChvYmoubmF2aWdhdGlvbkVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLCBCQVNFX1ZJREVPX1VSTCkudG9TdHJpbmcoKSxcbiAgICBiZXN0VGh1bWJuYWlsOiBwcmVwSW1nKG9iai50aHVtYm5haWwudGh1bWJuYWlscylbMF0sXG4gICAgdGh1bWJuYWlsczogcHJlcEltZyhvYmoudGh1bWJuYWlsLnRodW1ibmFpbHMpLFxuXG4gICAgb3duZXI6IF9wYXJzZU93bmVyKG9iaiksXG4gICAgZGVzY3JpcHRpb246IFVUSUwucGFyc2VUZXh0KG9iai5kZXNjcmlwdGlvblNuaXBwZXQpLFxuICAgIG1ldGE6IFVUSUwucGFyc2VUZXh0KG9iai50b3BNZXRhZGF0YUl0ZW1zWzBdLCAnJykuc3BsaXQoJyDCtyAnKSxcbiAgICBhY3RvcnM6ICFhY3RvcnNTdHJpbmcgPyBbXSA6IGFjdG9yc1N0cmluZy5zcGxpdCgnOiAnKVsxXS5zcGxpdCgnLCAnKSxcbiAgICBkaXJlY3RvcnM6ICFkaXJlY3RvcnNTdHJpbmcgPyBbXSA6IGRpcmVjdG9yc1N0cmluZy5zcGxpdCgnOiAnKVsxXS5zcGxpdCgnLCAnKSxcbiAgICBkdXJhdGlvbjogVVRJTC5wYXJzZVRleHQob2JqLmxlbmd0aFRleHQsICcnKSxcbiAgfTtcbn07XG5cbmNvbnN0IHBhcnNlU2hvcnQgPSBvYmogPT4ge1xuICBjb25zdCBjb3JlID0ge1xuICAgIHR5cGU6ICdzaG9ydCcsXG4gICAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai5oZWFkbGluZSwgJycpLFxuICAgIHZpZGVvSUQ6IG9iai52aWRlb0lkLFxuICAgIHVybDogbmV3IFVSTChvYmoubmF2aWdhdGlvbkVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLCBCQVNFX1ZJREVPX1VSTCkudG9TdHJpbmcoKSxcbiAgICBiZXN0VGh1bWJuYWlsOiBwcmVwSW1nKG9iai50aHVtYm5haWwudGh1bWJuYWlscylbMF0sXG4gICAgdGh1bWJuYWlsczogcHJlcEltZyhvYmoudGh1bWJuYWlsLnRodW1ibmFpbHMpLFxuICAgIHZpZXdzOiBVVElMLnBhcnNlVGV4dChvYmoudmlld0NvdW50VGV4dCwgJycpLFxuICAgIHB1Ymxpc2hlZDogbnVsbCxcbiAgICBjaGFubmVsOiBudWxsLFxuICB9O1xuICBjb25zdCByZWVsUGxheWVyT3ZlcmxheVJlbmRlcmVyID0gb2JqLm5hdmlnYXRpb25FbmRwb2ludC5yZWVsV2F0Y2hFbmRwb2ludC5vdmVybGF5LnJlZWxQbGF5ZXJPdmVybGF5UmVuZGVyZXI7XG4gIGlmIChyZWVsUGxheWVyT3ZlcmxheVJlbmRlcmVyLnJlZWxQbGF5ZXJIZWFkZXJTdXBwb3J0ZWRSZW5kZXJlcnMpIHtcbiAgICBjb25zdCBwbGF5ZXJIZWFkZXIgPSByZWVsUGxheWVyT3ZlcmxheVJlbmRlcmVyLnJlZWxQbGF5ZXJIZWFkZXJTdXBwb3J0ZWRSZW5kZXJlcnMucmVlbFBsYXllckhlYWRlclJlbmRlcmVyO1xuICAgIGNvbnN0IGNoYW5uZWxOYXZFbmRwb2ludCA9IHBsYXllckhlYWRlci5jaGFubmVsVGl0bGVUZXh0LnJ1bnNbMF0ubmF2aWdhdGlvbkVuZHBvaW50O1xuICAgIGNvcmUucHVibGlzaGVkID0gVVRJTC5wYXJzZVRleHQocGxheWVySGVhZGVyLnRpbWVzdGFtcFRleHQsICcnKTtcbiAgICBjb3JlLmNoYW5uZWwgPSB7XG4gICAgICBuYW1lOiBVVElMLnBhcnNlVGV4dChwbGF5ZXJIZWFkZXIuY2hhbm5lbFRpdGxlVGV4dCwgJycpLFxuICAgICAgY2hhbm5lbElEOiBjaGFubmVsTmF2RW5kcG9pbnQuYnJvd3NlRW5kcG9pbnQuYnJvd3NlSWQsXG4gICAgICB1cmw6IG5ldyBVUkwoY2hhbm5lbE5hdkVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsLCBCQVNFX1ZJREVPX1VSTCkudG9TdHJpbmcoKSxcbiAgICAgIGJlc3RBdmF0YXI6IHByZXBJbWcocGxheWVySGVhZGVyLmNoYW5uZWxUaHVtYm5haWwudGh1bWJuYWlscylbMF0gfHwgbnVsbCxcbiAgICAgIGF2YXRhcnM6IHByZXBJbWcocGxheWVySGVhZGVyLmNoYW5uZWxUaHVtYm5haWwudGh1bWJuYWlscyksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY29yZTtcbn07XG5cbmNvbnN0IHBhcnNlU2hvdyA9IG9iaiA9PiB7XG4gIGNvbnN0IHRodW1ibmFpbHMgPSBvYmoudGh1bWJuYWlsUmVuZGVyZXIuc2hvd0N1c3RvbVRodW1ibmFpbFJlbmRlcmVyLnRodW1ibmFpbC50aHVtYm5haWxzO1xuICBjb25zdCBvd25lciA9IF9wYXJzZU93bmVyKG9iaik7XG4gIGRlbGV0ZSBvd25lci5vd25lckJhZGdlcztcbiAgZGVsZXRlIG93bmVyLnZlcmlmaWVkO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ3Nob3cnLFxuICAgIHRpdGxlOiBVVElMLnBhcnNlVGV4dChvYmoudGl0bGUsICcnKSxcbiAgICBiZXN0VGh1bWJuYWlsOiBwcmVwSW1nKHRodW1ibmFpbHMpWzBdLFxuICAgIHRodW1ibmFpbHM6IHByZXBJbWcodGh1bWJuYWlscyksXG4gICAgdXJsOiBuZXcgVVJMKG9iai5uYXZpZ2F0aW9uRW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuICAgIHZpZGVvSUQ6IG9iai5uYXZpZ2F0aW9uRW5kcG9pbnQud2F0Y2hFbmRwb2ludC52aWRlb0lkLFxuICAgIHBsYXlsaXN0SUQ6IG9iai5uYXZpZ2F0aW9uRW5kcG9pbnQud2F0Y2hFbmRwb2ludC5wbGF5bGlzdElkLFxuICAgIGVwaXNvZGVzOiBVVElMLnBhcnNlSW50ZWdlckZyb21UZXh0KG9iai50aHVtYm5haWxPdmVybGF5c1swXS50aHVtYm5haWxPdmVybGF5Qm90dG9tUGFuZWxSZW5kZXJlci50ZXh0KSxcbiAgICBvd25lcixcbiAgfTtcbn07XG5cbmNvbnN0IHBhcnNlU2hlbGYgPSBvYmogPT4ge1xuICBsZXQgcmF3SXRlbXMgPSBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNvbnRlbnRzKSkge1xuICAgIHJhd0l0ZW1zID0gb2JqLmNvbnRlbnRzLm1hcCh4ID0+IHgucmljaEl0ZW1SZW5kZXJlci5jb250ZW50KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iai5pdGVtcykpIHtcbiAgICByYXdJdGVtcyA9IG9iai5pdGVtcztcbiAgfSBlbHNlIHtcbiAgICByYXdJdGVtcyA9IChvYmouY29udGVudC52ZXJ0aWNhbExpc3RSZW5kZXJlciB8fCBvYmouY29udGVudC5ob3Jpem9udGFsTW92aWVMaXN0UmVuZGVyZXIpLml0ZW1zO1xuICB9XG4gIC8vIE9wdGlvbmFsIG9iai50aHVtYm5haWwgaXMgaWdub3JlZFxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdzaGVsZicsXG4gICAgdGl0bGU6IFVUSUwucGFyc2VUZXh0KG9iai50aXRsZSwgJ1Nob3cgTW9yZScpLFxuICAgIGl0ZW1zOiByYXdJdGVtcy5tYXAoaSA9PiBwYXJzZUl0ZW0oaSkpLmZpbHRlcihhID0+IGEpLFxuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmFsaXNlZCBNZXRob2RcbiAqXG4gKiB1c2VkIGluIFBsYXlsaXN0LCBNb3ZpZSBhbmQgU2hvd1xuICogc2hvdyBkb2VzIG5ldmVyIHByb3ZpZGUgYmFkZ2VzIHRob3VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBmdWxsIFJlbmRlcmVyIE9iamVjdCBwcm92aWRlZCBieSBZb3VUdWJlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIG93bmVyXG4gKi9cbmNvbnN0IF9wYXJzZU93bmVyID0gb2JqID0+IHtcbiAgY29uc3Qgb3duZXIgPSAob2JqLnNob3J0QnlsaW5lVGV4dCAmJiBvYmouc2hvcnRCeWxpbmVUZXh0LnJ1bnNbMF0pIHx8XG4gICAgKG9iai5sb25nQnlsaW5lVGV4dCAmJiBvYmoubG9uZ0J5bGluZVRleHQucnVuc1swXSk7XG4gIGNvbnN0IG93bmVyVXJsID0gb3duZXIubmF2aWdhdGlvbkVuZHBvaW50LmJyb3dzZUVuZHBvaW50LmNhbm9uaWNhbEJhc2VVcmwgfHxcbiAgICBvd25lci5uYXZpZ2F0aW9uRW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmw7XG4gIGNvbnN0IGlzT2ZmaWNpYWwgPSAhIShvYmoub3duZXJCYWRnZXMgJiYgSlNPTi5zdHJpbmdpZnkob2JqLm93bmVyQmFkZ2VzKS5pbmNsdWRlcygnT0ZGSUNJQUwnKSk7XG4gIGNvbnN0IGlzVmVyaWZpZWQgPSAhIShvYmoub3duZXJCYWRnZXMgJiYgSlNPTi5zdHJpbmdpZnkob2JqLm93bmVyQmFkZ2VzKS5pbmNsdWRlcygnVkVSSUZJRUQnKSk7XG4gIGNvbnN0IGZhbGxiYWNrVVJMID0gb3duZXIubmF2aWdhdGlvbkVuZHBvaW50LmNvbW1hbmRNZXRhZGF0YS53ZWJDb21tYW5kTWV0YWRhdGEudXJsO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogb3duZXIudGV4dCxcbiAgICBjaGFubmVsSUQ6IG93bmVyLm5hdmlnYXRpb25FbmRwb2ludC5icm93c2VFbmRwb2ludC5icm93c2VJZCxcbiAgICB1cmw6IG5ldyBVUkwob3duZXJVcmwgfHwgZmFsbGJhY2tVUkwsIEJBU0VfVklERU9fVVJMKS50b1N0cmluZygpLFxuICAgIG93bmVyQmFkZ2VzOiBBcnJheS5pc0FycmF5KG9iai5vd25lckJhZGdlcykgPyBvYmoub3duZXJCYWRnZXMubWFwKGEgPT4gYS5tZXRhZGF0YUJhZGdlUmVuZGVyZXIudG9vbHRpcCkgOiBbXSxcbiAgICB2ZXJpZmllZDogaXNPZmZpY2lhbCB8fCBpc1ZlcmlmaWVkLFxuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytsr/lib/parseItem.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytsr/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/ytsr/lib/utils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const MINIGET = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\n\nconst BASE_URL = 'https://www.youtube.com/';\nconst DEFAULT_OPTIONS = { limit: 100, safeSearch: false };\nconst DEFAULT_QUERY = { gl: 'US', hl: 'en' };\nconst DEFAULT_CONTEXT = {\n  client: {\n    utcOffsetMinutes: 0,\n    gl: 'US',\n    hl: 'en',\n    clientName: 'WEB',\n    clientVersion: '<important information>',\n  },\n  user: {},\n  request: {},\n};\n\nexports.parseFilters = json => {\n  const pc = json.contents.twoColumnSearchResultsRenderer.primaryContents;\n  const wrapper = pc.sectionListRenderer || pc.richGridRenderer;\n  const filterWrapper = (wrapper.subMenu || wrapper.submenu).searchSubMenuRenderer.groups ||\n    json.header.searchHeaderRenderer.searchFilterButton.buttonRenderer.command.openPopupAction.popup\n      .searchFilterOptionsDialogRenderer.groups || [];\n  const parsedGroups = new Map();\n  for (const filterGroup of filterWrapper) {\n    const singleFilterGroup = new Map();\n    singleFilterGroup.active = null;\n    for (const filter of filterGroup.searchFilterGroupRenderer.filters) {\n      const isSet = !filter.searchFilterRenderer.navigationEndpoint;\n      let targetURL = null;\n      if (!isSet) targetURL = filter.searchFilterRenderer.navigationEndpoint.commandMetadata.webCommandMetadata.url;\n      const parsedFilter = {\n        name: parseText(filter.searchFilterRenderer.label, ''),\n        active: isSet,\n        url: isSet ? null : new URL(targetURL, BASE_URL).toString(),\n        description: filter.searchFilterRenderer.tooltip,\n      };\n      if (isSet) singleFilterGroup.active = parsedFilter;\n      singleFilterGroup.set(parsedFilter.name, parsedFilter);\n    }\n    parsedGroups.set(parseText(filterGroup.searchFilterGroupRenderer.title, 'Unknown Category'), singleFilterGroup);\n  }\n  return parsedGroups;\n};\n\nexports.parseBody = (body, options = {}) => {\n  let json = null;\n  try {\n    json = jsonAfter(body, 'var ytInitialData = ');\n  } catch (e) {\n    // Defaulting to null if failed to parse json => results in a retry in main\n  }\n  const apiKey = between(body, 'INNERTUBE_API_KEY\":\"', '\"') || between(body, 'innertubeApiKey\":\"', '\"');\n  const clientVersion = between(body, 'INNERTUBE_CONTEXT_CLIENT_VERSION\":\"', '\"') ||\n    between(body, 'innertube_context_client_version\":\"', '\"');\n  // Make deep copy and set clientVersion\n  const context = JSON.parse(JSON.stringify(DEFAULT_CONTEXT));\n  context.client.clientVersion = clientVersion;\n  // Add params to context\n  if (options.gl) context.client.gl = options.gl;\n  if (options.hl) context.client.hl = options.hl;\n  if (options.utcOffsetMinutes) context.client.utcOffsetMinutes = options.utcOffsetMinutes;\n  if (options.safeSearch) context.user.enableSafetyMode = true;\n  // Return multiple values\n  return { json, apiKey, context };\n};\n\n// Parsing utility\nconst parseText = exports.parseText = (txt, def = null) => {\n  if (typeof txt !== 'object') return def;\n  if (Object.prototype.hasOwnProperty.call(txt, 'simpleText')) return txt.simpleText;\n  if (Array.isArray(txt.runs)) {\n    return txt.runs.map(a => a.text).join('');\n  }\n  return def;\n};\n\nexports.parseIntegerFromText = txt => Number(parseText(txt).replace(/\\D+/g, ''));\n\n// Request Utility\nexports.doPost = async(url, payload, reqOpts = {}) => {\n  // Enforce POST-Request\n  reqOpts.method = 'POST';\n  const req = MINIGET(url, reqOpts);\n  // Write request body\n  if (payload) req.once('request', r => r.write(JSON.stringify(payload)));\n  // Await response-text and parse json\n  return JSON.parse(await req.text());\n};\n\n// Guarantee that all arguments are valid\nexports.checkArgs = (searchString, options = {}) => {\n  // Validation\n  if (!searchString) {\n    throw new Error('search string is mandatory');\n  }\n  if (typeof searchString !== 'string') {\n    throw new Error('search string must be of type string');\n  }\n\n  // Normalisation\n  let obj = Object.assign({}, DEFAULT_OPTIONS, options);\n  // Other optional params\n  if (!isNaN(obj.pages) && obj.pages > 0) {\n    // Disable limit if pages is provided\n    obj.limit = Infinity;\n  } else if (isNaN(obj.limit) || obj.limit <= 0) {\n    // Default limit\n    obj.pages = Infinity;\n    obj.limit = DEFAULT_OPTIONS.limit;\n  }\n  if (typeof obj.safeSearch !== 'boolean') obj.safeSearch = DEFAULT_OPTIONS.safeSearch;\n  // Default requestOptions\n  obj.requestOptions = Object.assign({}, options.requestOptions);\n  // Unlink requestOptions#headers\n  if (obj.requestOptions.headers) {\n    obj.requestOptions.headers = JSON.parse(JSON.stringify(obj.requestOptions.headers));\n  }\n  // Setting cookie in request headers to get safe search results\n  if (obj.safeSearch) {\n    if (!obj.requestOptions.headers) obj.requestOptions.headers = {};\n    if (!obj.requestOptions.headers.Cookie) obj.requestOptions.headers.Cookie = [];\n    obj.requestOptions.headers.Cookie.push('PREF=f2=8000000');\n  }\n  // Set required parameter: query\n  const inputURL = new URL(searchString, BASE_URL);\n  if (searchString.startsWith(BASE_URL) && inputURL.pathname === '/results' && inputURL.searchParams.has('sp')) {\n    // Watch out for requests with a set filter\n    // in such a case searchString would be an url including `sp` & `search_query` querys\n    if (!inputURL.searchParams.get('search_query')) {\n      throw new Error('filter links have to include a \"search_string\" query');\n    }\n    // Object.fromEntries not supported in nodejs < v12\n    obj.query = {};\n    for (const key of inputURL.searchParams.keys()) {\n      obj.query[key] = inputURL.searchParams.get(key);\n    }\n  } else {\n    // If no filter-link default to passing it all as query\n    obj.query = { search_query: searchString };\n  }\n  // Save the search term itself for potential later use\n  obj.search = obj.query.search_query;\n\n  // Add additional information\n  obj.query = Object.assign({}, DEFAULT_QUERY, obj.query);\n  if (options && options.gl) obj.query.gl = options.gl;\n  if (options && options.hl) obj.query.hl = options.hl;\n  return obj;\n};\n\n// Sorts Images in descending order & normalizes the url's\nexports.prepImg = img => {\n  // Resolve url\n  img.forEach(x => x.url = x.url ? new URL(x.url, BASE_URL).toString() : null);\n  // Sort\n  return img.sort((a, b) => b.width - a.width);\n};\n\nexports.parseWrapper = primaryContents => {\n  let rawItems = [];\n  let continuation = null;\n\n  // Older Format\n  if (primaryContents.sectionListRenderer) {\n    rawItems = primaryContents.sectionListRenderer.contents\n      .find(x => Object.keys(x)[0] === 'itemSectionRenderer')\n      .itemSectionRenderer.contents;\n    continuation = primaryContents.sectionListRenderer.contents\n      .find(x => Object.keys(x)[0] === 'continuationItemRenderer');\n  // Newer Format\n  } else if (primaryContents.richGridRenderer) {\n    rawItems = primaryContents.richGridRenderer.contents\n      .filter(x => !Object.prototype.hasOwnProperty.call(x, 'continuationItemRenderer'))\n      .map(x => (x.richItemRenderer || x.richSectionRenderer).content);\n    continuation = primaryContents.richGridRenderer.contents\n      .find(x => Object.prototype.hasOwnProperty.call(x, 'continuationItemRenderer'));\n  }\n\n  return { rawItems, continuation };\n};\n\nexports.parsePage2Wrapper = continuationItems => {\n  let rawItems = [];\n  let continuation = null;\n\n  for (const ci of continuationItems) {\n    // Older Format\n    if (Object.prototype.hasOwnProperty.call(ci, 'itemSectionRenderer')) {\n      rawItems.push(...ci.itemSectionRenderer.contents);\n    // Newer Format\n    } else if (Object.prototype.hasOwnProperty.call(ci, 'richItemRenderer')) {\n      rawItems.push(ci.richItemRenderer.content);\n    } else if (Object.prototype.hasOwnProperty.call(ci, 'richSectionRenderer')) {\n      rawItems.push(ci.richSectionRenderer.content);\n    // Continuation\n    } else if (Object.prototype.hasOwnProperty.call(ci, 'continuationItemRenderer')) {\n      continuation = ci;\n    }\n  }\n\n  return { rawItems, continuation };\n};\n\n/**\n * Extract json after given string.\n * loosely based on utils#between\n *\n * @param {string} haystack\n * @param {string} left\n * @returns {Object|null} the parsed json or null\n */\nconst jsonAfter = (haystack, left) => {\n  const pos = haystack.indexOf(left);\n  if (pos === -1) { return null; }\n  haystack = haystack.slice(pos + left.length);\n  try {\n    return JSON.parse(cutAfterJSON(haystack));\n  } catch (e) {\n    return null;\n  }\n};\n\n/**\n * Extract string inbetween another.\n * Property of https://github.com/fent/node-ytdl-core/blob/master/lib/utils.js\n *\n * @param {string} haystack\n * @param {string} left\n * @param {string} right\n * @returns {string}\n */\nconst between = (haystack, left, right) => {\n  let pos;\n  pos = haystack.indexOf(left);\n  if (pos === -1) { return ''; }\n  pos += left.length;\n  haystack = haystack.slice(pos);\n  pos = haystack.indexOf(right);\n  if (pos === -1) { return ''; }\n  haystack = haystack.slice(0, pos);\n  return haystack;\n};\n\n/**\n * Match begin and end braces of input JSON, return only json\n * Property of https://github.com/fent/node-ytdl-core/blob/master/lib/utils.js\n *\n * @param {string} mixedJson\n * @returns {string}\n * @throws {Error} no json or invalid json\n*/\nconst cutAfterJSON = exports.cutAfterJSON = mixedJson => {\n  let open, close;\n  if (mixedJson[0] === '[') {\n    open = '[';\n    close = ']';\n  } else if (mixedJson[0] === '{') {\n    open = '{';\n    close = '}';\n  }\n\n  if (!open) {\n    throw new Error(`Can't cut unsupported JSON (need to begin with [ or { ) but got: ${mixedJson[0]}`);\n  }\n\n  // States if the loop is currently in a string\n  let isString = false;\n\n  // States if the current character is treated as escaped or not\n  let isEscaped = false;\n\n  // Current open brackets to be closed\n  let counter = 0;\n\n  let i;\n  for (i = 0; i < mixedJson.length; i++) {\n    // Toggle the isString boolean when leaving/entering string\n    if (mixedJson[i] === '\"' && !isEscaped) {\n      isString = !isString;\n      continue;\n    }\n\n    // Toggle the isEscaped boolean for every backslash\n    // Reset for every regular character\n    isEscaped = mixedJson[i] === '\\\\' && !isEscaped;\n\n    if (isString) continue;\n\n    if (mixedJson[i] === open) {\n      counter++;\n    } else if (mixedJson[i] === close) {\n      counter--;\n    }\n\n    // All brackets have been closed, thus end of JSON is reached\n    if (counter === 0) {\n      // Return the cut JSON\n      return mixedJson.substr(0, i + 1);\n    }\n  }\n\n  // We ran through the whole string and ended up with an unclosed bracket\n  throw Error(\"Can't cut unsupported JSON (no matching closing bracket found)\");\n};\n\n// Exports for testing\nexports._hidden = {\n  jsonAfter, between, cutAfterJSON,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRzci9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVM7O0FBRWpDO0FBQ0EsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVO0FBQ1YsYUFBYTtBQUNiOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsYUFBYTtBQUNiLGNBQWM7QUFDZDs7QUFFQTtBQUNBLDJFQUEyRSxhQUFhLGFBQWE7QUFDckc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWFudHViZS8uL25vZGVfbW9kdWxlcy95dHNyL2xpYi91dGlscy5qcz8zMWU1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1JTklHRVQgPSByZXF1aXJlKCdtaW5pZ2V0Jyk7XG5cbmNvbnN0IEJBU0VfVVJMID0gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tLyc7XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7IGxpbWl0OiAxMDAsIHNhZmVTZWFyY2g6IGZhbHNlIH07XG5jb25zdCBERUZBVUxUX1FVRVJZID0geyBnbDogJ1VTJywgaGw6ICdlbicgfTtcbmNvbnN0IERFRkFVTFRfQ09OVEVYVCA9IHtcbiAgY2xpZW50OiB7XG4gICAgdXRjT2Zmc2V0TWludXRlczogMCxcbiAgICBnbDogJ1VTJyxcbiAgICBobDogJ2VuJyxcbiAgICBjbGllbnROYW1lOiAnV0VCJyxcbiAgICBjbGllbnRWZXJzaW9uOiAnPGltcG9ydGFudCBpbmZvcm1hdGlvbj4nLFxuICB9LFxuICB1c2VyOiB7fSxcbiAgcmVxdWVzdDoge30sXG59O1xuXG5leHBvcnRzLnBhcnNlRmlsdGVycyA9IGpzb24gPT4ge1xuICBjb25zdCBwYyA9IGpzb24uY29udGVudHMudHdvQ29sdW1uU2VhcmNoUmVzdWx0c1JlbmRlcmVyLnByaW1hcnlDb250ZW50cztcbiAgY29uc3Qgd3JhcHBlciA9IHBjLnNlY3Rpb25MaXN0UmVuZGVyZXIgfHwgcGMucmljaEdyaWRSZW5kZXJlcjtcbiAgY29uc3QgZmlsdGVyV3JhcHBlciA9ICh3cmFwcGVyLnN1Yk1lbnUgfHwgd3JhcHBlci5zdWJtZW51KS5zZWFyY2hTdWJNZW51UmVuZGVyZXIuZ3JvdXBzIHx8XG4gICAganNvbi5oZWFkZXIuc2VhcmNoSGVhZGVyUmVuZGVyZXIuc2VhcmNoRmlsdGVyQnV0dG9uLmJ1dHRvblJlbmRlcmVyLmNvbW1hbmQub3BlblBvcHVwQWN0aW9uLnBvcHVwXG4gICAgICAuc2VhcmNoRmlsdGVyT3B0aW9uc0RpYWxvZ1JlbmRlcmVyLmdyb3VwcyB8fCBbXTtcbiAgY29uc3QgcGFyc2VkR3JvdXBzID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGZpbHRlckdyb3VwIG9mIGZpbHRlcldyYXBwZXIpIHtcbiAgICBjb25zdCBzaW5nbGVGaWx0ZXJHcm91cCA9IG5ldyBNYXAoKTtcbiAgICBzaW5nbGVGaWx0ZXJHcm91cC5hY3RpdmUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlckdyb3VwLnNlYXJjaEZpbHRlckdyb3VwUmVuZGVyZXIuZmlsdGVycykge1xuICAgICAgY29uc3QgaXNTZXQgPSAhZmlsdGVyLnNlYXJjaEZpbHRlclJlbmRlcmVyLm5hdmlnYXRpb25FbmRwb2ludDtcbiAgICAgIGxldCB0YXJnZXRVUkwgPSBudWxsO1xuICAgICAgaWYgKCFpc1NldCkgdGFyZ2V0VVJMID0gZmlsdGVyLnNlYXJjaEZpbHRlclJlbmRlcmVyLm5hdmlnYXRpb25FbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybDtcbiAgICAgIGNvbnN0IHBhcnNlZEZpbHRlciA9IHtcbiAgICAgICAgbmFtZTogcGFyc2VUZXh0KGZpbHRlci5zZWFyY2hGaWx0ZXJSZW5kZXJlci5sYWJlbCwgJycpLFxuICAgICAgICBhY3RpdmU6IGlzU2V0LFxuICAgICAgICB1cmw6IGlzU2V0ID8gbnVsbCA6IG5ldyBVUkwodGFyZ2V0VVJMLCBCQVNFX1VSTCkudG9TdHJpbmcoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGZpbHRlci5zZWFyY2hGaWx0ZXJSZW5kZXJlci50b29sdGlwLFxuICAgICAgfTtcbiAgICAgIGlmIChpc1NldCkgc2luZ2xlRmlsdGVyR3JvdXAuYWN0aXZlID0gcGFyc2VkRmlsdGVyO1xuICAgICAgc2luZ2xlRmlsdGVyR3JvdXAuc2V0KHBhcnNlZEZpbHRlci5uYW1lLCBwYXJzZWRGaWx0ZXIpO1xuICAgIH1cbiAgICBwYXJzZWRHcm91cHMuc2V0KHBhcnNlVGV4dChmaWx0ZXJHcm91cC5zZWFyY2hGaWx0ZXJHcm91cFJlbmRlcmVyLnRpdGxlLCAnVW5rbm93biBDYXRlZ29yeScpLCBzaW5nbGVGaWx0ZXJHcm91cCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZEdyb3Vwcztcbn07XG5cbmV4cG9ydHMucGFyc2VCb2R5ID0gKGJvZHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBsZXQganNvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAganNvbiA9IGpzb25BZnRlcihib2R5LCAndmFyIHl0SW5pdGlhbERhdGEgPSAnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIERlZmF1bHRpbmcgdG8gbnVsbCBpZiBmYWlsZWQgdG8gcGFyc2UganNvbiA9PiByZXN1bHRzIGluIGEgcmV0cnkgaW4gbWFpblxuICB9XG4gIGNvbnN0IGFwaUtleSA9IGJldHdlZW4oYm9keSwgJ0lOTkVSVFVCRV9BUElfS0VZXCI6XCInLCAnXCInKSB8fCBiZXR3ZWVuKGJvZHksICdpbm5lcnR1YmVBcGlLZXlcIjpcIicsICdcIicpO1xuICBjb25zdCBjbGllbnRWZXJzaW9uID0gYmV0d2Vlbihib2R5LCAnSU5ORVJUVUJFX0NPTlRFWFRfQ0xJRU5UX1ZFUlNJT05cIjpcIicsICdcIicpIHx8XG4gICAgYmV0d2Vlbihib2R5LCAnaW5uZXJ0dWJlX2NvbnRleHRfY2xpZW50X3ZlcnNpb25cIjpcIicsICdcIicpO1xuICAvLyBNYWtlIGRlZXAgY29weSBhbmQgc2V0IGNsaWVudFZlcnNpb25cbiAgY29uc3QgY29udGV4dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoREVGQVVMVF9DT05URVhUKSk7XG4gIGNvbnRleHQuY2xpZW50LmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uO1xuICAvLyBBZGQgcGFyYW1zIHRvIGNvbnRleHRcbiAgaWYgKG9wdGlvbnMuZ2wpIGNvbnRleHQuY2xpZW50LmdsID0gb3B0aW9ucy5nbDtcbiAgaWYgKG9wdGlvbnMuaGwpIGNvbnRleHQuY2xpZW50LmhsID0gb3B0aW9ucy5obDtcbiAgaWYgKG9wdGlvbnMudXRjT2Zmc2V0TWludXRlcykgY29udGV4dC5jbGllbnQudXRjT2Zmc2V0TWludXRlcyA9IG9wdGlvbnMudXRjT2Zmc2V0TWludXRlcztcbiAgaWYgKG9wdGlvbnMuc2FmZVNlYXJjaCkgY29udGV4dC51c2VyLmVuYWJsZVNhZmV0eU1vZGUgPSB0cnVlO1xuICAvLyBSZXR1cm4gbXVsdGlwbGUgdmFsdWVzXG4gIHJldHVybiB7IGpzb24sIGFwaUtleSwgY29udGV4dCB9O1xufTtcblxuLy8gUGFyc2luZyB1dGlsaXR5XG5jb25zdCBwYXJzZVRleHQgPSBleHBvcnRzLnBhcnNlVGV4dCA9ICh0eHQsIGRlZiA9IG51bGwpID0+IHtcbiAgaWYgKHR5cGVvZiB0eHQgIT09ICdvYmplY3QnKSByZXR1cm4gZGVmO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR4dCwgJ3NpbXBsZVRleHQnKSkgcmV0dXJuIHR4dC5zaW1wbGVUZXh0O1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eHQucnVucykpIHtcbiAgICByZXR1cm4gdHh0LnJ1bnMubWFwKGEgPT4gYS50ZXh0KS5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gZGVmO1xufTtcblxuZXhwb3J0cy5wYXJzZUludGVnZXJGcm9tVGV4dCA9IHR4dCA9PiBOdW1iZXIocGFyc2VUZXh0KHR4dCkucmVwbGFjZSgvXFxEKy9nLCAnJykpO1xuXG4vLyBSZXF1ZXN0IFV0aWxpdHlcbmV4cG9ydHMuZG9Qb3N0ID0gYXN5bmModXJsLCBwYXlsb2FkLCByZXFPcHRzID0ge30pID0+IHtcbiAgLy8gRW5mb3JjZSBQT1NULVJlcXVlc3RcbiAgcmVxT3B0cy5tZXRob2QgPSAnUE9TVCc7XG4gIGNvbnN0IHJlcSA9IE1JTklHRVQodXJsLCByZXFPcHRzKTtcbiAgLy8gV3JpdGUgcmVxdWVzdCBib2R5XG4gIGlmIChwYXlsb2FkKSByZXEub25jZSgncmVxdWVzdCcsIHIgPT4gci53cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICAvLyBBd2FpdCByZXNwb25zZS10ZXh0IGFuZCBwYXJzZSBqc29uXG4gIHJldHVybiBKU09OLnBhcnNlKGF3YWl0IHJlcS50ZXh0KCkpO1xufTtcblxuLy8gR3VhcmFudGVlIHRoYXQgYWxsIGFyZ3VtZW50cyBhcmUgdmFsaWRcbmV4cG9ydHMuY2hlY2tBcmdzID0gKHNlYXJjaFN0cmluZywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIC8vIFZhbGlkYXRpb25cbiAgaWYgKCFzZWFyY2hTdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlYXJjaCBzdHJpbmcgaXMgbWFuZGF0b3J5Jyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWFyY2hTdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZWFyY2ggc3RyaW5nIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgfVxuXG4gIC8vIE5vcm1hbGlzYXRpb25cbiAgbGV0IG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIC8vIE90aGVyIG9wdGlvbmFsIHBhcmFtc1xuICBpZiAoIWlzTmFOKG9iai5wYWdlcykgJiYgb2JqLnBhZ2VzID4gMCkge1xuICAgIC8vIERpc2FibGUgbGltaXQgaWYgcGFnZXMgaXMgcHJvdmlkZWRcbiAgICBvYmoubGltaXQgPSBJbmZpbml0eTtcbiAgfSBlbHNlIGlmIChpc05hTihvYmoubGltaXQpIHx8IG9iai5saW1pdCA8PSAwKSB7XG4gICAgLy8gRGVmYXVsdCBsaW1pdFxuICAgIG9iai5wYWdlcyA9IEluZmluaXR5O1xuICAgIG9iai5saW1pdCA9IERFRkFVTFRfT1BUSU9OUy5saW1pdDtcbiAgfVxuICBpZiAodHlwZW9mIG9iai5zYWZlU2VhcmNoICE9PSAnYm9vbGVhbicpIG9iai5zYWZlU2VhcmNoID0gREVGQVVMVF9PUFRJT05TLnNhZmVTZWFyY2g7XG4gIC8vIERlZmF1bHQgcmVxdWVzdE9wdGlvbnNcbiAgb2JqLnJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gIC8vIFVubGluayByZXF1ZXN0T3B0aW9ucyNoZWFkZXJzXG4gIGlmIChvYmoucmVxdWVzdE9wdGlvbnMuaGVhZGVycykge1xuICAgIG9iai5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmoucmVxdWVzdE9wdGlvbnMuaGVhZGVycykpO1xuICB9XG4gIC8vIFNldHRpbmcgY29va2llIGluIHJlcXVlc3QgaGVhZGVycyB0byBnZXQgc2FmZSBzZWFyY2ggcmVzdWx0c1xuICBpZiAob2JqLnNhZmVTZWFyY2gpIHtcbiAgICBpZiAoIW9iai5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKSBvYmoucmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICAgIGlmICghb2JqLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMuQ29va2llKSBvYmoucmVxdWVzdE9wdGlvbnMuaGVhZGVycy5Db29raWUgPSBbXTtcbiAgICBvYmoucmVxdWVzdE9wdGlvbnMuaGVhZGVycy5Db29raWUucHVzaCgnUFJFRj1mMj04MDAwMDAwJyk7XG4gIH1cbiAgLy8gU2V0IHJlcXVpcmVkIHBhcmFtZXRlcjogcXVlcnlcbiAgY29uc3QgaW5wdXRVUkwgPSBuZXcgVVJMKHNlYXJjaFN0cmluZywgQkFTRV9VUkwpO1xuICBpZiAoc2VhcmNoU3RyaW5nLnN0YXJ0c1dpdGgoQkFTRV9VUkwpICYmIGlucHV0VVJMLnBhdGhuYW1lID09PSAnL3Jlc3VsdHMnICYmIGlucHV0VVJMLnNlYXJjaFBhcmFtcy5oYXMoJ3NwJykpIHtcbiAgICAvLyBXYXRjaCBvdXQgZm9yIHJlcXVlc3RzIHdpdGggYSBzZXQgZmlsdGVyXG4gICAgLy8gaW4gc3VjaCBhIGNhc2Ugc2VhcmNoU3RyaW5nIHdvdWxkIGJlIGFuIHVybCBpbmNsdWRpbmcgYHNwYCAmIGBzZWFyY2hfcXVlcnlgIHF1ZXJ5c1xuICAgIGlmICghaW5wdXRVUkwuc2VhcmNoUGFyYW1zLmdldCgnc2VhcmNoX3F1ZXJ5JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIGxpbmtzIGhhdmUgdG8gaW5jbHVkZSBhIFwic2VhcmNoX3N0cmluZ1wiIHF1ZXJ5Jyk7XG4gICAgfVxuICAgIC8vIE9iamVjdC5mcm9tRW50cmllcyBub3Qgc3VwcG9ydGVkIGluIG5vZGVqcyA8IHYxMlxuICAgIG9iai5xdWVyeSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGlucHV0VVJMLnNlYXJjaFBhcmFtcy5rZXlzKCkpIHtcbiAgICAgIG9iai5xdWVyeVtrZXldID0gaW5wdXRVUkwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBubyBmaWx0ZXItbGluayBkZWZhdWx0IHRvIHBhc3NpbmcgaXQgYWxsIGFzIHF1ZXJ5XG4gICAgb2JqLnF1ZXJ5ID0geyBzZWFyY2hfcXVlcnk6IHNlYXJjaFN0cmluZyB9O1xuICB9XG4gIC8vIFNhdmUgdGhlIHNlYXJjaCB0ZXJtIGl0c2VsZiBmb3IgcG90ZW50aWFsIGxhdGVyIHVzZVxuICBvYmouc2VhcmNoID0gb2JqLnF1ZXJ5LnNlYXJjaF9xdWVyeTtcblxuICAvLyBBZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICBvYmoucXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1FVRVJZLCBvYmoucXVlcnkpO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsKSBvYmoucXVlcnkuZ2wgPSBvcHRpb25zLmdsO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhsKSBvYmoucXVlcnkuaGwgPSBvcHRpb25zLmhsO1xuICByZXR1cm4gb2JqO1xufTtcblxuLy8gU29ydHMgSW1hZ2VzIGluIGRlc2NlbmRpbmcgb3JkZXIgJiBub3JtYWxpemVzIHRoZSB1cmwnc1xuZXhwb3J0cy5wcmVwSW1nID0gaW1nID0+IHtcbiAgLy8gUmVzb2x2ZSB1cmxcbiAgaW1nLmZvckVhY2goeCA9PiB4LnVybCA9IHgudXJsID8gbmV3IFVSTCh4LnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCkgOiBudWxsKTtcbiAgLy8gU29ydFxuICByZXR1cm4gaW1nLnNvcnQoKGEsIGIpID0+IGIud2lkdGggLSBhLndpZHRoKTtcbn07XG5cbmV4cG9ydHMucGFyc2VXcmFwcGVyID0gcHJpbWFyeUNvbnRlbnRzID0+IHtcbiAgbGV0IHJhd0l0ZW1zID0gW107XG4gIGxldCBjb250aW51YXRpb24gPSBudWxsO1xuXG4gIC8vIE9sZGVyIEZvcm1hdFxuICBpZiAocHJpbWFyeUNvbnRlbnRzLnNlY3Rpb25MaXN0UmVuZGVyZXIpIHtcbiAgICByYXdJdGVtcyA9IHByaW1hcnlDb250ZW50cy5zZWN0aW9uTGlzdFJlbmRlcmVyLmNvbnRlbnRzXG4gICAgICAuZmluZCh4ID0+IE9iamVjdC5rZXlzKHgpWzBdID09PSAnaXRlbVNlY3Rpb25SZW5kZXJlcicpXG4gICAgICAuaXRlbVNlY3Rpb25SZW5kZXJlci5jb250ZW50cztcbiAgICBjb250aW51YXRpb24gPSBwcmltYXJ5Q29udGVudHMuc2VjdGlvbkxpc3RSZW5kZXJlci5jb250ZW50c1xuICAgICAgLmZpbmQoeCA9PiBPYmplY3Qua2V5cyh4KVswXSA9PT0gJ2NvbnRpbnVhdGlvbkl0ZW1SZW5kZXJlcicpO1xuICAvLyBOZXdlciBGb3JtYXRcbiAgfSBlbHNlIGlmIChwcmltYXJ5Q29udGVudHMucmljaEdyaWRSZW5kZXJlcikge1xuICAgIHJhd0l0ZW1zID0gcHJpbWFyeUNvbnRlbnRzLnJpY2hHcmlkUmVuZGVyZXIuY29udGVudHNcbiAgICAgIC5maWx0ZXIoeCA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdjb250aW51YXRpb25JdGVtUmVuZGVyZXInKSlcbiAgICAgIC5tYXAoeCA9PiAoeC5yaWNoSXRlbVJlbmRlcmVyIHx8IHgucmljaFNlY3Rpb25SZW5kZXJlcikuY29udGVudCk7XG4gICAgY29udGludWF0aW9uID0gcHJpbWFyeUNvbnRlbnRzLnJpY2hHcmlkUmVuZGVyZXIuY29udGVudHNcbiAgICAgIC5maW5kKHggPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdjb250aW51YXRpb25JdGVtUmVuZGVyZXInKSk7XG4gIH1cblxuICByZXR1cm4geyByYXdJdGVtcywgY29udGludWF0aW9uIH07XG59O1xuXG5leHBvcnRzLnBhcnNlUGFnZTJXcmFwcGVyID0gY29udGludWF0aW9uSXRlbXMgPT4ge1xuICBsZXQgcmF3SXRlbXMgPSBbXTtcbiAgbGV0IGNvbnRpbnVhdGlvbiA9IG51bGw7XG5cbiAgZm9yIChjb25zdCBjaSBvZiBjb250aW51YXRpb25JdGVtcykge1xuICAgIC8vIE9sZGVyIEZvcm1hdFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2ksICdpdGVtU2VjdGlvblJlbmRlcmVyJykpIHtcbiAgICAgIHJhd0l0ZW1zLnB1c2goLi4uY2kuaXRlbVNlY3Rpb25SZW5kZXJlci5jb250ZW50cyk7XG4gICAgLy8gTmV3ZXIgRm9ybWF0XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2ksICdyaWNoSXRlbVJlbmRlcmVyJykpIHtcbiAgICAgIHJhd0l0ZW1zLnB1c2goY2kucmljaEl0ZW1SZW5kZXJlci5jb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaSwgJ3JpY2hTZWN0aW9uUmVuZGVyZXInKSkge1xuICAgICAgcmF3SXRlbXMucHVzaChjaS5yaWNoU2VjdGlvblJlbmRlcmVyLmNvbnRlbnQpO1xuICAgIC8vIENvbnRpbnVhdGlvblxuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNpLCAnY29udGludWF0aW9uSXRlbVJlbmRlcmVyJykpIHtcbiAgICAgIGNvbnRpbnVhdGlvbiA9IGNpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHJhd0l0ZW1zLCBjb250aW51YXRpb24gfTtcbn07XG5cbi8qKlxuICogRXh0cmFjdCBqc29uIGFmdGVyIGdpdmVuIHN0cmluZy5cbiAqIGxvb3NlbHkgYmFzZWQgb24gdXRpbHMjYmV0d2VlblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXlzdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gdGhlIHBhcnNlZCBqc29uIG9yIG51bGxcbiAqL1xuY29uc3QganNvbkFmdGVyID0gKGhheXN0YWNrLCBsZWZ0KSA9PiB7XG4gIGNvbnN0IHBvcyA9IGhheXN0YWNrLmluZGV4T2YobGVmdCk7XG4gIGlmIChwb3MgPT09IC0xKSB7IHJldHVybiBudWxsOyB9XG4gIGhheXN0YWNrID0gaGF5c3RhY2suc2xpY2UocG9zICsgbGVmdC5sZW5ndGgpO1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGN1dEFmdGVySlNPTihoYXlzdGFjaykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogRXh0cmFjdCBzdHJpbmcgaW5iZXR3ZWVuIGFub3RoZXIuXG4gKiBQcm9wZXJ0eSBvZiBodHRwczovL2dpdGh1Yi5jb20vZmVudC9ub2RlLXl0ZGwtY29yZS9ibG9iL21hc3Rlci9saWIvdXRpbHMuanNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGF5c3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XG4gKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGJldHdlZW4gPSAoaGF5c3RhY2ssIGxlZnQsIHJpZ2h0KSA9PiB7XG4gIGxldCBwb3M7XG4gIHBvcyA9IGhheXN0YWNrLmluZGV4T2YobGVmdCk7XG4gIGlmIChwb3MgPT09IC0xKSB7IHJldHVybiAnJzsgfVxuICBwb3MgKz0gbGVmdC5sZW5ndGg7XG4gIGhheXN0YWNrID0gaGF5c3RhY2suc2xpY2UocG9zKTtcbiAgcG9zID0gaGF5c3RhY2suaW5kZXhPZihyaWdodCk7XG4gIGlmIChwb3MgPT09IC0xKSB7IHJldHVybiAnJzsgfVxuICBoYXlzdGFjayA9IGhheXN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gIHJldHVybiBoYXlzdGFjaztcbn07XG5cbi8qKlxuICogTWF0Y2ggYmVnaW4gYW5kIGVuZCBicmFjZXMgb2YgaW5wdXQgSlNPTiwgcmV0dXJuIG9ubHkganNvblxuICogUHJvcGVydHkgb2YgaHR0cHM6Ly9naXRodWIuY29tL2ZlbnQvbm9kZS15dGRsLWNvcmUvYmxvYi9tYXN0ZXIvbGliL3V0aWxzLmpzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1peGVkSnNvblxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEB0aHJvd3Mge0Vycm9yfSBubyBqc29uIG9yIGludmFsaWQganNvblxuKi9cbmNvbnN0IGN1dEFmdGVySlNPTiA9IGV4cG9ydHMuY3V0QWZ0ZXJKU09OID0gbWl4ZWRKc29uID0+IHtcbiAgbGV0IG9wZW4sIGNsb3NlO1xuICBpZiAobWl4ZWRKc29uWzBdID09PSAnWycpIHtcbiAgICBvcGVuID0gJ1snO1xuICAgIGNsb3NlID0gJ10nO1xuICB9IGVsc2UgaWYgKG1peGVkSnNvblswXSA9PT0gJ3snKSB7XG4gICAgb3BlbiA9ICd7JztcbiAgICBjbG9zZSA9ICd9JztcbiAgfVxuXG4gIGlmICghb3Blbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3V0IHVuc3VwcG9ydGVkIEpTT04gKG5lZWQgdG8gYmVnaW4gd2l0aCBbIG9yIHsgKSBidXQgZ290OiAke21peGVkSnNvblswXX1gKTtcbiAgfVxuXG4gIC8vIFN0YXRlcyBpZiB0aGUgbG9vcCBpcyBjdXJyZW50bHkgaW4gYSBzdHJpbmdcbiAgbGV0IGlzU3RyaW5nID0gZmFsc2U7XG5cbiAgLy8gU3RhdGVzIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyB0cmVhdGVkIGFzIGVzY2FwZWQgb3Igbm90XG4gIGxldCBpc0VzY2FwZWQgPSBmYWxzZTtcblxuICAvLyBDdXJyZW50IG9wZW4gYnJhY2tldHMgdG8gYmUgY2xvc2VkXG4gIGxldCBjb3VudGVyID0gMDtcblxuICBsZXQgaTtcbiAgZm9yIChpID0gMDsgaSA8IG1peGVkSnNvbi5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRvZ2dsZSB0aGUgaXNTdHJpbmcgYm9vbGVhbiB3aGVuIGxlYXZpbmcvZW50ZXJpbmcgc3RyaW5nXG4gICAgaWYgKG1peGVkSnNvbltpXSA9PT0gJ1wiJyAmJiAhaXNFc2NhcGVkKSB7XG4gICAgICBpc1N0cmluZyA9ICFpc1N0cmluZztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRvZ2dsZSB0aGUgaXNFc2NhcGVkIGJvb2xlYW4gZm9yIGV2ZXJ5IGJhY2tzbGFzaFxuICAgIC8vIFJlc2V0IGZvciBldmVyeSByZWd1bGFyIGNoYXJhY3RlclxuICAgIGlzRXNjYXBlZCA9IG1peGVkSnNvbltpXSA9PT0gJ1xcXFwnICYmICFpc0VzY2FwZWQ7XG5cbiAgICBpZiAoaXNTdHJpbmcpIGNvbnRpbnVlO1xuXG4gICAgaWYgKG1peGVkSnNvbltpXSA9PT0gb3Blbikge1xuICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSBpZiAobWl4ZWRKc29uW2ldID09PSBjbG9zZSkge1xuICAgICAgY291bnRlci0tO1xuICAgIH1cblxuICAgIC8vIEFsbCBicmFja2V0cyBoYXZlIGJlZW4gY2xvc2VkLCB0aHVzIGVuZCBvZiBKU09OIGlzIHJlYWNoZWRcbiAgICBpZiAoY291bnRlciA9PT0gMCkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBjdXQgSlNPTlxuICAgICAgcmV0dXJuIG1peGVkSnNvbi5zdWJzdHIoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIHJhbiB0aHJvdWdoIHRoZSB3aG9sZSBzdHJpbmcgYW5kIGVuZGVkIHVwIHdpdGggYW4gdW5jbG9zZWQgYnJhY2tldFxuICB0aHJvdyBFcnJvcihcIkNhbid0IGN1dCB1bnN1cHBvcnRlZCBKU09OIChubyBtYXRjaGluZyBjbG9zaW5nIGJyYWNrZXQgZm91bmQpXCIpO1xufTtcblxuLy8gRXhwb3J0cyBmb3IgdGVzdGluZ1xuZXhwb3J0cy5faGlkZGVuID0ge1xuICBqc29uQWZ0ZXIsIGJldHdlZW4sIGN1dEFmdGVySlNPTixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytsr/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytsr/package.json":
/*!****************************************!*\
  !*** ./node_modules/ytsr/package.json ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"ytsr","version":"3.8.4","description":"Simple package to search YouTube - no strings attached.","keywords":["youtube","search","yt","ytsearcher","api","playlist","channel","video","scrape","pagination","promise"],"homepage":"https://github.com/TimeForANinja/node-ytsr#readme","bugs":{"url":"https://github.com/TimeForANinja/node-ytsr/issues"},"repository":{"type":"git","url":"git://github.com/TimeForANinja/node-ytsr.git"},"license":"MIT","author":"Tobias Kutscha (https://github.com/TimeForANinja)","main":"./lib/main.js","types":"./typings/index.d.ts","files":["lib","typings"],"scripts":{"lint":"eslint ./","lint:fix":"eslint --fix ./","lint:typings":"tslint typings/index.d.ts","lint:typings:fix":"tslint --fix typings/index.d.ts","mocha":"mocha -- -t 16000 test/*-test.js","mocha:coverage":"mocha -- -t 16000 test/*-test.js --exclude test/e2e-test.js","nyc":"nyc --reporter=lcov npm run-script mocha","nyc:coverage":"nyc --reporter=lcov npm run-script mocha:coverage","test":"npm run-script nyc","test:coverage":"npm run-script nyc:coverage && codecov"},"dependencies":{"miniget":"^4.2.2"},"devDependencies":{"assert-diff":"^3.0.2","codecov":"^3.8.1","dtslint":"^4.0.8","eslint":"^7.23.0","mocha":"^10.2.0","nock":"^13.0.11","nyc":"^15.1.0","typescript":"^4.2.3"},"engines":{"node":">=8"}}');

/***/ })

};
;